"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureUTxOBigInt = exports.utxoFilter = exports.areRegistersDenselyPacked = exports.utxoDiff = exports.utxoSum = void 0;
const assertions_1 = require("./assertions");
const bigIntLiterals_1 = require("./bigIntLiterals");
const bigIntUtils_1 = require("./bigIntUtils");
const objectUtils_1 = require("./objectUtils");
const NANOERGS_TOKEN_ID = "nanoErgs";
function utxoSum(boxes, tokenId) {
    const balances = {};
    for (const box of boxes) {
        if ((0, objectUtils_1.isUndefined)(tokenId) || tokenId === NANOERGS_TOKEN_ID) {
            balances[NANOERGS_TOKEN_ID] = (balances[NANOERGS_TOKEN_ID] || bigIntLiterals_1._0n) + (0, bigIntUtils_1.ensureBigInt)(box.value);
        }
        if (tokenId !== NANOERGS_TOKEN_ID) {
            for (const token of box.assets) {
                if ((0, objectUtils_1.isDefined)(tokenId) && tokenId !== token.tokenId) {
                    continue;
                }
                balances[token.tokenId] = (balances[token.tokenId] || bigIntLiterals_1._0n) + (0, bigIntUtils_1.ensureBigInt)(token.amount);
            }
        }
    }
    if ((0, objectUtils_1.isDefined)(tokenId)) {
        return balances[tokenId] || bigIntLiterals_1._0n;
    }
    return {
        nanoErgs: balances[NANOERGS_TOKEN_ID] || bigIntLiterals_1._0n,
        tokens: Object.keys(balances)
            .filter((x) => x !== NANOERGS_TOKEN_ID)
            .map((tokenId) => ({ tokenId, amount: balances[tokenId] }))
    };
}
exports.utxoSum = utxoSum;
function utxoDiff(minuend, subtrahend) {
    if (Array.isArray(minuend)) {
        minuend = utxoSum(minuend);
    }
    if (Array.isArray(subtrahend)) {
        subtrahend = utxoSum(subtrahend);
    }
    const tokens = [];
    const nanoErgs = minuend.nanoErgs - subtrahend.nanoErgs;
    for (const token of minuend.tokens) {
        const balance = token.amount - (subtrahend.tokens.find((t) => t.tokenId === token.tokenId)?.amount || bigIntLiterals_1._0n);
        if (balance !== bigIntLiterals_1._0n) {
            tokens.push({ tokenId: token.tokenId, amount: balance });
        }
    }
    return { nanoErgs, tokens };
}
exports.utxoDiff = utxoDiff;
const MIN_NON_MANDATORY_REGISTER_INDEX = 4;
const MAX_NON_MANDATORY_REGISTER_INDEX = 9;
function areRegistersDenselyPacked(registers) {
    let lastIndex = 0;
    for (let i = MIN_NON_MANDATORY_REGISTER_INDEX; i <= MAX_NON_MANDATORY_REGISTER_INDEX; i++) {
        const key = `R${i}`;
        if (registers[key]) {
            if (i === MIN_NON_MANDATORY_REGISTER_INDEX) {
                lastIndex = i;
                continue;
            }
            if (i - lastIndex > 1) {
                return false;
            }
            lastIndex = i;
        }
    }
    return true;
}
exports.areRegistersDenselyPacked = areRegistersDenselyPacked;
function utxoFilter(utxos, filterParams) {
    if ((0, assertions_1.isEmpty)(filterParams) || (0, assertions_1.isEmpty)(utxos)) {
        return utxos;
    }
    const { by, max } = filterParams;
    let filtered = utxos;
    if (by) {
        filtered = utxos.filter(by);
        if ((0, assertions_1.isEmpty)(filtered)) {
            return filtered;
        }
    }
    if (!max) {
        return filtered;
    }
    if ((0, objectUtils_1.isDefined)(max.aggregatedDistinctTokens)) {
        const tokenIds = _getDistinctTokenIds(filtered, max.aggregatedDistinctTokens);
        filtered = filtered.filter((utxo) => (0, assertions_1.isEmpty)(utxo.assets) || utxo.assets.every((token) => tokenIds.has(token.tokenId)));
    }
    if ((0, objectUtils_1.isDefined)(max.count) && filtered.length > max.count) {
        filtered = filtered.slice(0, max.count);
    }
    return filtered;
}
exports.utxoFilter = utxoFilter;
function _getDistinctTokenIds(utxos, max) {
    const tokenIds = new Set();
    for (let i = 0; i < utxos.length && tokenIds.size < max; i++) {
        if ((0, assertions_1.isEmpty)(utxos[i].assets) || utxos[i].assets.length > max) {
            continue;
        }
        for (const token of utxos[i].assets) {
            tokenIds.add(token.tokenId);
        }
    }
    return tokenIds;
}
function ensureUTxOBigInt(box) {
    return {
        ...box,
        value: (0, bigIntUtils_1.ensureBigInt)(box.value),
        assets: box.assets.map((token) => ({
            tokenId: token.tokenId,
            amount: (0, bigIntUtils_1.ensureBigInt)(token.amount)
        }))
    };
}
exports.ensureUTxOBigInt = ensureUTxOBigInt;
//# sourceMappingURL=boxUtils.js.map