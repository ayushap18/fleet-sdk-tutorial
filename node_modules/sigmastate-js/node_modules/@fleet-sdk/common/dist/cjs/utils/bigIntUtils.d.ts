import { Amount } from "../types";
type NumberLike = string | number | bigint | boolean;
export declare function ensureBigInt(number: NumberLike): bigint;
type ParsingOptions = {
    /**
     * Number of decimals.
     */
    decimals?: number;
    /**
     * Thousand mark char.
     * Default: `.`
     */
    decimalMark?: string;
};
export declare function undecimalize(decimalStr: string, options?: ParsingOptions | number): bigint;
type FormattingOptions = {
    /**
     * Number of decimals.
     */
    decimals: number;
    /**
     * Thousand mark char.
     */
    thousandMark?: string;
    /**
     * Decimal mark char.
     * Default: `.`
     */
    decimalMark?: string;
};
export declare function decimalize(value: Amount, options?: FormattingOptions | number): string;
export declare function percent(value: bigint, percentage: bigint, precision?: bigint): bigint;
export declare function sumBy<T>(collection: readonly T[], iteratee: (value: T) => bigint, condition?: (value: T) => boolean): bigint;
/**
 * Converts a hex string to bigint.
 * @param hex The hex string to be converted.
 * @returns The bigint value represented by the hex string.
 */
export declare function hexToBigInt(hex: string): bigint;
/**
 * Serializes a `BigInt` to a hex string
 * @param value The bigint value to be serialized
 * @returns Hex representation for the provided `number`.
 */
export declare function bigIntToHex(value: bigint): string;
/**
 * Returns the two’s complement of a bigint value.
 * @param value The bigint value to negate.
 * @returns The two’s complement of `number` as a bigint.
 */
export declare function _bitNegate(value: bigint): bigint;
export declare function min<T extends bigint | number>(...numbers: T[]): T;
export declare function max<T extends bigint | number>(...numbers: T[]): T;
export {};
