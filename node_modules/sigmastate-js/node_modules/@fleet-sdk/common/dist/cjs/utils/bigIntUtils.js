"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.max = exports.min = exports._bitNegate = exports.bigIntToHex = exports.hexToBigInt = exports.sumBy = exports.percent = exports.decimalize = exports.undecimalize = exports.ensureBigInt = void 0;
const arrayUtils_1 = require("./arrayUtils");
const assertions_1 = require("./assertions");
const bigIntLiterals_1 = require("./bigIntLiterals");
const objectUtils_1 = require("./objectUtils");
function ensureBigInt(number) {
    return typeof number === "bigint" ? number : BigInt(number);
}
exports.ensureBigInt = ensureBigInt;
function undecimalize(decimalStr, options) {
    if (!decimalStr) {
        return bigIntLiterals_1._0n;
    }
    options = typeof options == "number" ? { decimals: options } : options;
    if ((0, objectUtils_1.isUndefined)(options)) {
        options = {};
    }
    options.decimals = options.decimals || 0;
    options.decimalMark = options.decimalMark || ".";
    const fragments = decimalStr.split(options.decimalMark);
    if (fragments.length > 2) {
        throw new Error("Invalid numeric string.");
    }
    let [integer, decimal] = fragments;
    integer = _removeLeadingZeros(integer);
    const negative = integer.startsWith("-") ? "-" : "";
    if (!decimal) {
        decimal = "0".repeat(options.decimals);
    }
    else if (decimal.length < options.decimals) {
        decimal = decimal.padEnd(options.decimals, "0");
    }
    return BigInt(negative + _stripNonDigits(integer + decimal));
}
exports.undecimalize = undecimalize;
function _stripNonDigits(value) {
    return value.replace(/\D/g, "");
}
function decimalize(value, options) {
    value = ensureBigInt(value);
    if (!options) {
        return value.toString();
    }
    options = typeof options == "number" ? { decimals: options } : options;
    options.decimals = options.decimals || 0;
    options.decimalMark = options.decimalMark || ".";
    const pow = bigIntLiterals_1._10n ** BigInt(options.decimals);
    const integer = value / pow;
    const decimal = value - integer * pow;
    return _buildFormattedDecimal(integer.toString(10), decimal.toString(10), options);
}
exports.decimalize = decimalize;
function percent(value, percentage, precision = 2n) {
    return (value * percentage) / 10n ** precision;
}
exports.percent = percent;
function _buildFormattedDecimal(integer, decimal, options) {
    const integerPart = _addThousandMarks(integer, options.thousandMark);
    const decimalPart = _stripTrailingZeros(decimal.padStart(options.decimals, "0"));
    if (decimalPart) {
        return `${integerPart}${options.decimalMark}${decimalPart}`;
    }
    else {
        return integerPart;
    }
}
function _addThousandMarks(value, mark) {
    if (!mark) {
        return value;
    }
    return value.replace(/\B(?=(\d{3})+(?!\d))/g, mark);
}
function _stripTrailingZeros(value) {
    if (!value.endsWith("0")) {
        return value;
    }
    return value.replace(/\.?0+$/, "");
}
function _removeLeadingZeros(value) {
    if (!value.startsWith("0")) {
        return value;
    }
    return value.replace(/^0+\.?/, "");
}
function sumBy(collection, iteratee, condition) {
    let acc = bigIntLiterals_1._0n;
    if ((0, assertions_1.isEmpty)(collection)) {
        return acc;
    }
    for (const item of collection) {
        if ((0, objectUtils_1.isUndefined)(condition) || condition(item)) {
            acc += iteratee(item);
        }
    }
    return acc;
}
exports.sumBy = sumBy;
/**
 * Converts a hex string to bigint.
 * @param hex The hex string to be converted.
 * @returns The bigint value represented by the hex string.
 */
function hexToBigInt(hex) {
    // https://coolaj86.com/articles/convert-hex-to-decimal-with-js-bigints/
    if (hex.length % 2) {
        hex = "0" + hex;
    }
    const value = BigInt("0x" + hex);
    const highByte = parseInt(hex.slice(0, 2), 16);
    if (0x80 & highByte) {
        return -_bitNegate(value); // add two's complement and invert the number to negative
    }
    return value;
}
exports.hexToBigInt = hexToBigInt;
/**
 * Serializes a `BigInt` to a hex string
 * @param value The bigint value to be serialized
 * @returns Hex representation for the provided `number`.
 */
function bigIntToHex(value) {
    // implementation inspired on
    // https://coolaj86.com/articles/convert-decimal-to-hex-with-js-bigints/
    const positive = value >= bigIntLiterals_1._0n;
    if (!positive) {
        value = _bitNegate(value);
    }
    let hex = value.toString(16);
    if (hex.length % 2) {
        hex = "0" + hex;
    }
    if (positive && 0x80 & parseInt(hex.slice(0, 2), 16)) {
        hex = "00" + hex;
    }
    return hex;
}
exports.bigIntToHex = bigIntToHex;
/**
 * Returns the two’s complement of a bigint value.
 * @param value The bigint value to negate.
 * @returns The two’s complement of `number` as a bigint.
 */
function _bitNegate(value) {
    const negative = value < bigIntLiterals_1._0n;
    if (negative) {
        value = -value; // turn into a positive number
    }
    const bits = value.toString(2);
    let bitLen = bits.length; // convert to binary
    const mod = bitLen % 8;
    if (mod > 0) {
        bitLen += 8 - mod;
    }
    else if (negative && (0, arrayUtils_1.first)(bits) === "1" && bits.indexOf("1", 1) !== -1) {
        bitLen += 8;
    }
    const mask = (1n << BigInt(bitLen)) - 1n; // create a mask
    return (~value & mask) + 1n; // invert bits, mask it, and add one
}
exports._bitNegate = _bitNegate;
function min(...numbers) {
    let min = (0, arrayUtils_1.first)(numbers);
    for (const num of numbers) {
        if (num < min) {
            min = num;
        }
    }
    return min;
}
exports.min = min;
function max(...numbers) {
    let max = (0, arrayUtils_1.first)(numbers);
    for (const num of numbers) {
        if (num > max) {
            max = num;
        }
    }
    return max;
}
exports.max = max;
//# sourceMappingURL=bigIntUtils.js.map