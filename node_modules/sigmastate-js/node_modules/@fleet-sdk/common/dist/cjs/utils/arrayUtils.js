"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uniqBy = exports.uniq = exports.endsWith = exports.startsWith = exports.areEqualBy = exports.areEqual = exports.orderBy = exports.chunk = exports.hasDuplicatesBy = exports.hasDuplicates = exports.at = exports.last = exports.first = void 0;
const assertions_1 = require("./assertions");
function first(array) {
    if (!array)
        return undefined;
    (0, assertions_1.assert)(array.length > 0, "Empty array.");
    return array[0];
}
exports.first = first;
function last(array) {
    if (!array)
        return undefined;
    (0, assertions_1.assert)(array.length > 0, "Empty array.");
    return at(array, -1);
}
exports.last = last;
function at(array, index) {
    const len = array?.length;
    if (!len)
        return undefined;
    if (index < 0) {
        index += len;
    }
    return array[index];
}
exports.at = at;
/**
 * Check for duplicate elements using the equality operator
 */
function hasDuplicates(array) {
    return array.some((item, index) => {
        return array.indexOf(item) !== index;
    });
}
exports.hasDuplicates = hasDuplicates;
/**
 * Check for duplicate keys in complex elements
 */
function hasDuplicatesBy(array, selector) {
    return array.some((item, index) => {
        return array.findIndex((x) => selector(x) === selector(item)) !== index;
    });
}
exports.hasDuplicatesBy = hasDuplicatesBy;
function chunk(array, size) {
    if (array.length <= size) {
        return [array];
    }
    const chunks = [];
    for (let i = 0; i < array.length; i += size) {
        chunks.push(array.slice(i, i + size));
    }
    return chunks;
}
exports.chunk = chunk;
function orderBy(array, iteratee, order = "asc") {
    return [...array].sort((a, b) => {
        if (iteratee(a) > iteratee(b)) {
            return order === "asc" ? 1 : -1;
        }
        else if (iteratee(a) < iteratee(b)) {
            return order === "asc" ? -1 : 1;
        }
        else {
            return 0;
        }
    });
}
exports.orderBy = orderBy;
function areEqual(array1, array2) {
    if (array1 === array2) {
        return true;
    }
    if (array1.length != array2.length) {
        return false;
    }
    for (let i = 0; i < array1.length; i++) {
        if (array1[i] !== array2[i]) {
            return false;
        }
    }
    return true;
}
exports.areEqual = areEqual;
function areEqualBy(array1, array2, selector) {
    if (array1 === array2) {
        return true;
    }
    if (array1.length != array2.length) {
        return false;
    }
    for (let i = 0; i < array1.length; i++) {
        if (selector(array1[i]) !== selector(array2[i])) {
            return false;
        }
    }
    return true;
}
exports.areEqualBy = areEqualBy;
function startsWith(array, target) {
    if (array === target) {
        return true;
    }
    if (target.length > array.length) {
        return false;
    }
    for (let i = 0; i < target.length; i++) {
        if (target[i] !== array[i]) {
            return false;
        }
    }
    return true;
}
exports.startsWith = startsWith;
function endsWith(array, target) {
    if (array === target) {
        return true;
    }
    if (target.length > array.length) {
        return false;
    }
    const offset = array.length - target.length;
    for (let i = target.length - 1; i >= 0; i--) {
        if (target[i] !== array[i + offset]) {
            return false;
        }
    }
    return true;
}
exports.endsWith = endsWith;
function uniq(array) {
    if ((0, assertions_1.isEmpty)(array)) {
        return array;
    }
    return Array.from(new Set(array));
}
exports.uniq = uniq;
function uniqBy(array, selector, selection = "keep-first") {
    if ((0, assertions_1.isEmpty)(array)) {
        return array;
    }
    return Array.from(array
        .reduce((map, e) => {
        const key = selector(e);
        if (selection === "keep-first" && map.has(key)) {
            return map;
        }
        return map.set(key, e);
    }, new Map())
        .values());
}
exports.uniqBy = uniqBy;
//# sourceMappingURL=arrayUtils.js.map