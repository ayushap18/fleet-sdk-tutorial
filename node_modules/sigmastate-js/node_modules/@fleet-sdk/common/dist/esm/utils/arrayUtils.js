import { assert, isEmpty } from "./assertions";
export function first(array) {
    if (!array)
        return undefined;
    assert(array.length > 0, "Empty array.");
    return array[0];
}
export function last(array) {
    if (!array)
        return undefined;
    assert(array.length > 0, "Empty array.");
    return at(array, -1);
}
export function at(array, index) {
    const len = array?.length;
    if (!len)
        return undefined;
    if (index < 0) {
        index += len;
    }
    return array[index];
}
/**
 * Check for duplicate elements using the equality operator
 */
export function hasDuplicates(array) {
    return array.some((item, index) => {
        return array.indexOf(item) !== index;
    });
}
/**
 * Check for duplicate keys in complex elements
 */
export function hasDuplicatesBy(array, selector) {
    return array.some((item, index) => {
        return array.findIndex((x) => selector(x) === selector(item)) !== index;
    });
}
export function chunk(array, size) {
    if (array.length <= size) {
        return [array];
    }
    const chunks = [];
    for (let i = 0; i < array.length; i += size) {
        chunks.push(array.slice(i, i + size));
    }
    return chunks;
}
export function orderBy(array, iteratee, order = "asc") {
    return [...array].sort((a, b) => {
        if (iteratee(a) > iteratee(b)) {
            return order === "asc" ? 1 : -1;
        }
        else if (iteratee(a) < iteratee(b)) {
            return order === "asc" ? -1 : 1;
        }
        else {
            return 0;
        }
    });
}
export function areEqual(array1, array2) {
    if (array1 === array2) {
        return true;
    }
    if (array1.length != array2.length) {
        return false;
    }
    for (let i = 0; i < array1.length; i++) {
        if (array1[i] !== array2[i]) {
            return false;
        }
    }
    return true;
}
export function areEqualBy(array1, array2, selector) {
    if (array1 === array2) {
        return true;
    }
    if (array1.length != array2.length) {
        return false;
    }
    for (let i = 0; i < array1.length; i++) {
        if (selector(array1[i]) !== selector(array2[i])) {
            return false;
        }
    }
    return true;
}
export function startsWith(array, target) {
    if (array === target) {
        return true;
    }
    if (target.length > array.length) {
        return false;
    }
    for (let i = 0; i < target.length; i++) {
        if (target[i] !== array[i]) {
            return false;
        }
    }
    return true;
}
export function endsWith(array, target) {
    if (array === target) {
        return true;
    }
    if (target.length > array.length) {
        return false;
    }
    const offset = array.length - target.length;
    for (let i = target.length - 1; i >= 0; i--) {
        if (target[i] !== array[i + offset]) {
            return false;
        }
    }
    return true;
}
export function uniq(array) {
    if (isEmpty(array)) {
        return array;
    }
    return Array.from(new Set(array));
}
export function uniqBy(array, selector, selection = "keep-first") {
    if (isEmpty(array)) {
        return array;
    }
    return Array.from(array
        .reduce((map, e) => {
        const key = selector(e);
        if (selection === "keep-first" && map.has(key)) {
            return map;
        }
        return map.set(key, e);
    }, new Map())
        .values());
}
//# sourceMappingURL=arrayUtils.js.map