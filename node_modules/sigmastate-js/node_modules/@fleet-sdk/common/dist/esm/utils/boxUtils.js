import { isEmpty } from "./assertions";
import { _0n } from "./bigIntLiterals";
import { ensureBigInt } from "./bigIntUtils";
import { isDefined, isUndefined } from "./objectUtils";
const NANOERGS_TOKEN_ID = "nanoErgs";
export function utxoSum(boxes, tokenId) {
    const balances = {};
    for (const box of boxes) {
        if (isUndefined(tokenId) || tokenId === NANOERGS_TOKEN_ID) {
            balances[NANOERGS_TOKEN_ID] = (balances[NANOERGS_TOKEN_ID] || _0n) + ensureBigInt(box.value);
        }
        if (tokenId !== NANOERGS_TOKEN_ID) {
            for (const token of box.assets) {
                if (isDefined(tokenId) && tokenId !== token.tokenId) {
                    continue;
                }
                balances[token.tokenId] = (balances[token.tokenId] || _0n) + ensureBigInt(token.amount);
            }
        }
    }
    if (isDefined(tokenId)) {
        return balances[tokenId] || _0n;
    }
    return {
        nanoErgs: balances[NANOERGS_TOKEN_ID] || _0n,
        tokens: Object.keys(balances)
            .filter((x) => x !== NANOERGS_TOKEN_ID)
            .map((tokenId) => ({ tokenId, amount: balances[tokenId] }))
    };
}
export function utxoDiff(minuend, subtrahend) {
    if (Array.isArray(minuend)) {
        minuend = utxoSum(minuend);
    }
    if (Array.isArray(subtrahend)) {
        subtrahend = utxoSum(subtrahend);
    }
    const tokens = [];
    const nanoErgs = minuend.nanoErgs - subtrahend.nanoErgs;
    for (const token of minuend.tokens) {
        const balance = token.amount - (subtrahend.tokens.find((t) => t.tokenId === token.tokenId)?.amount || _0n);
        if (balance !== _0n) {
            tokens.push({ tokenId: token.tokenId, amount: balance });
        }
    }
    return { nanoErgs, tokens };
}
const MIN_NON_MANDATORY_REGISTER_INDEX = 4;
const MAX_NON_MANDATORY_REGISTER_INDEX = 9;
export function areRegistersDenselyPacked(registers) {
    let lastIndex = 0;
    for (let i = MIN_NON_MANDATORY_REGISTER_INDEX; i <= MAX_NON_MANDATORY_REGISTER_INDEX; i++) {
        const key = `R${i}`;
        if (registers[key]) {
            if (i === MIN_NON_MANDATORY_REGISTER_INDEX) {
                lastIndex = i;
                continue;
            }
            if (i - lastIndex > 1) {
                return false;
            }
            lastIndex = i;
        }
    }
    return true;
}
export function utxoFilter(utxos, filterParams) {
    if (isEmpty(filterParams) || isEmpty(utxos)) {
        return utxos;
    }
    const { by, max } = filterParams;
    let filtered = utxos;
    if (by) {
        filtered = utxos.filter(by);
        if (isEmpty(filtered)) {
            return filtered;
        }
    }
    if (!max) {
        return filtered;
    }
    if (isDefined(max.aggregatedDistinctTokens)) {
        const tokenIds = _getDistinctTokenIds(filtered, max.aggregatedDistinctTokens);
        filtered = filtered.filter((utxo) => isEmpty(utxo.assets) || utxo.assets.every((token) => tokenIds.has(token.tokenId)));
    }
    if (isDefined(max.count) && filtered.length > max.count) {
        filtered = filtered.slice(0, max.count);
    }
    return filtered;
}
function _getDistinctTokenIds(utxos, max) {
    const tokenIds = new Set();
    for (let i = 0; i < utxos.length && tokenIds.size < max; i++) {
        if (isEmpty(utxos[i].assets) || utxos[i].assets.length > max) {
            continue;
        }
        for (const token of utxos[i].assets) {
            tokenIds.add(token.tokenId);
        }
    }
    return tokenIds;
}
export function ensureUTxOBigInt(box) {
    return {
        ...box,
        value: ensureBigInt(box.value),
        assets: box.assets.map((token) => ({
            tokenId: token.tokenId,
            amount: ensureBigInt(token.amount)
        }))
    };
}
//# sourceMappingURL=boxUtils.js.map