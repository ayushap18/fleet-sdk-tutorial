{"version":3,"sources":["../src/errors/duplicateInputSelectionError.ts","../src/errors/insufficientInputs.ts","../src/builder/selector/strategies/accumulativeSelectionStrategy.ts","../src/builder/selector/strategies/customSelectionStrategy.ts","../src/builder/selector/boxSelector.ts","../src/builder/selector/strategies/cherryPickSelectionStrategy.ts","../src/errors/duplicateInputError.ts","../src/errors/insufficientTokenAmount.ts","../src/errors/invalidAddress.ts","../src/errors/invalidInput.ts","../src/errors/invalidRegistersPacking.ts","../src/errors/malformedTransaction.ts","../src/models/collections/tokensCollection.ts","../src/errors/maxTokensOverflow.ts","../src/errors/notAllowedTokenBurning.ts","../src/errors/notFoundError.ts","../src/errors/undefinedCreationHeight.ts","../src/errors/undefinedMintingContext.ts","../src/models/utils.ts","../src/models/ergoAddress.ts","../src/models/ergoBox.ts","../src/models/ergoUnsignedInput.ts","../src/models/ergoUnsignedTransaction.ts","../src/models/collections/inputsCollection.ts","../src/models/collections/outputsCollection.ts","../src/models/ergoTree.ts","../src/models/ergoMessage.ts","../src/builder/outputBuilder.ts","../src/errors/nonStandardizedMinting.ts","../src/builder/pluginContext.ts","../src/builder/transactionBuilderSettings.ts","../src/builder/transactionBuilder.ts","../src/constantSerializer.ts"],"names":["some","_0n","sumBy","isEmpty","utxoSum","isUndefined","orderBy","isDefined","ensureBigInt","first","AddressType","validateEcPoint","concatBytes","base58","blake2b256","hex","Collection","Network","ensureBytes","SigmaByteWriter","areEqual","isHex","utf8","utxoDiff","SerSConstant"],"mappings":"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","file":"index.mjs","sourcesContent":["export class DuplicateInputSelectionError extends Error {\n  constructor() {\n    super(\n      \"One or more inputs was selected more than one time by the current selection strategy.\"\n    );\n  }\n}\n","import { some } from \"@fleet-sdk/common\";\nimport type { SelectionTarget } from \"../builder/selector/boxSelector\";\n\nexport class InsufficientInputs extends Error {\n  readonly unreached: SelectionTarget;\n\n  constructor(unreached: SelectionTarget) {\n    const strings = [];\n    if (unreached.nanoErgs) {\n      strings.push(buildString(\"nanoErgs\", unreached.nanoErgs));\n    }\n\n    if (some(unreached.tokens)) {\n      for (const token of unreached.tokens) {\n        strings.push(buildString(token.tokenId, token.amount));\n      }\n    }\n\n    super(`Insufficient inputs:${strings.join()}`);\n\n    this.unreached = unreached;\n  }\n}\n\nfunction buildString(tokenId: string, amount?: bigint): string {\n  return `\\n  > ${tokenId}: ${amount?.toString()}`;\n}\n","import {\n  type Box,\n  isDefined,\n  some,\n  type TokenId,\n  type TokenTargetAmount\n} from \"@fleet-sdk/common\";\nimport { _0n, isEmpty, isUndefined, sumBy, utxoSum } from \"@fleet-sdk/common\";\nimport type { SelectionTarget } from \"../boxSelector\";\nimport type { ISelectionStrategy } from \"./ISelectionStrategy\";\n\n/**\n * Accumulative selection strategy accumulates inputs until the target amounts\n * value is reached, skipping detrimental inputs.\n */\nexport class AccumulativeSelectionStrategy implements ISelectionStrategy {\n  private _inputs!: Box<bigint>[];\n\n  select(inputs: Box<bigint>[], target: SelectionTarget): Box<bigint>[] {\n    this._inputs = inputs;\n\n    let selection: Box<bigint>[] = [];\n    if (some(target.tokens)) {\n      selection = this._selectTokens(target.tokens);\n    }\n\n    const selectedNanoErgs = sumBy(selection, (input) => input.value);\n    if (\n      (isUndefined(target.nanoErgs) && isEmpty(target.tokens)) ||\n      (isDefined(target.nanoErgs) && selectedNanoErgs < target.nanoErgs)\n    ) {\n      const targetAmount = isDefined(target.nanoErgs)\n        ? target.nanoErgs - selectedNanoErgs\n        : undefined;\n\n      selection = selection.concat(this._select(targetAmount));\n    }\n\n    return selection;\n  }\n\n  private _selectTokens(targets: TokenTargetAmount<bigint>[]): Box<bigint>[] {\n    let selection: Box<bigint>[] = [];\n\n    for (const target of targets) {\n      const targetAmount = isDefined(target.amount)\n        ? target.amount - utxoSum(selection, target.tokenId)\n        : undefined;\n\n      if (targetAmount && targetAmount <= _0n) {\n        continue;\n      }\n\n      selection = selection.concat(this._select(targetAmount, target.tokenId));\n    }\n\n    return selection;\n  }\n\n  private _select(target?: bigint, tokenId?: TokenId): Box<bigint>[] {\n    const inputs = this._inputs;\n    let acc = _0n;\n    let selection: Box<bigint>[] = [];\n\n    if (isUndefined(target)) {\n      if (tokenId) {\n        selection = inputs.filter((x) =>\n          x.assets.some((asset) => asset.tokenId === tokenId)\n        );\n      } else {\n        selection = inputs;\n      }\n    } else {\n      for (let i = 0; i < inputs.length && acc < target; i++) {\n        if (tokenId) {\n          for (const token of inputs[i].assets) {\n            if (token.tokenId !== tokenId) {\n              continue;\n            }\n\n            acc += token.amount;\n            selection.push(inputs[i]);\n          }\n        } else {\n          acc += inputs[i].value;\n          selection.push(inputs[i]);\n        }\n      }\n    }\n\n    if (some(selection)) {\n      this._inputs = this._inputs.filter((input) => !selection.includes(input));\n    }\n\n    return selection;\n  }\n}\n","import type { Box } from \"@fleet-sdk/common\";\nimport type { SelectionTarget } from \"../boxSelector\";\nimport type { ISelectionStrategy } from \"./ISelectionStrategy\";\n\nexport type SelectorFunction = (\n  inputs: Box<bigint>[],\n  target?: SelectionTarget\n) => Box<bigint>[];\n\n/**\n * Custom selection strategy supports custom selections implementations.\n */\nexport class CustomSelectionStrategy implements ISelectionStrategy {\n  private readonly _selector: SelectorFunction;\n\n  constructor(selector: SelectorFunction) {\n    this._selector = selector;\n  }\n\n  select(inputs: Box<bigint>[], target?: SelectionTarget): Box<bigint>[] {\n    return this._selector(inputs, target);\n  }\n}\n","import {\n  _0n,\n  type Amount,\n  type Box,\n  type BoxCandidate,\n  type BoxId,\n  ensureBigInt,\n  type FilterPredicate,\n  first,\n  hasDuplicatesBy,\n  isEmpty,\n  isUndefined,\n  type OneOrMore,\n  orderBy,\n  some,\n  type SortingDirection,\n  type SortingSelector,\n  sumBy,\n  type TokenTargetAmount,\n  utxoSum\n} from \"@fleet-sdk/common\";\nimport { DuplicateInputSelectionError } from \"../../errors/duplicateInputSelectionError\";\nimport { InsufficientInputs } from \"../../errors/insufficientInputs\";\nimport type { ISelectionStrategy } from \"./strategies/ISelectionStrategy\";\nimport { AccumulativeSelectionStrategy } from \"./strategies/accumulativeSelectionStrategy\";\nimport {\n  CustomSelectionStrategy,\n  type SelectorFunction\n} from \"./strategies/customSelectionStrategy\";\n\nexport type SelectionTarget = {\n  nanoErgs?: bigint;\n  tokens?: TokenTargetAmount<bigint>[];\n};\n\nexport class BoxSelector<T extends Box<bigint>> {\n  private readonly _inputs: Box<bigint>[];\n  private _strategy?: ISelectionStrategy;\n  private _ensureFilterPredicate?: FilterPredicate<Box<bigint>>;\n  private _selector?: SortingSelector<Box<bigint>>;\n  private _sortDirection?: SortingDirection;\n  private _ensureInclusionBoxIds?: Set<BoxId>;\n\n  constructor(inputs: T[]) {\n    this._inputs = inputs;\n  }\n\n  public defineStrategy(strategy: ISelectionStrategy | SelectorFunction): BoxSelector<T> {\n    if (this._isISelectionStrategyImplementation(strategy)) {\n      this._strategy = strategy;\n    } else {\n      this._strategy = new CustomSelectionStrategy(strategy);\n    }\n\n    return this;\n  }\n\n  public select(target: SelectionTarget): T[] {\n    if (!this._strategy) {\n      this._strategy = new AccumulativeSelectionStrategy();\n    }\n\n    const remaining = this._deepCloneTarget(target);\n    let unselected = [...this._inputs];\n    let selected: Box<bigint>[] = [];\n\n    const predicate = this._ensureFilterPredicate;\n    let inclusion = this._ensureInclusionBoxIds;\n\n    // if the target has a token that is being minted, then the first input should be included\n    if (target.tokens?.some((x) => x.tokenId === unselected[0].boxId)) {\n      inclusion = new Set(this._ensureInclusionBoxIds).add(unselected[0].boxId);\n    }\n\n    if (predicate) {\n      if (inclusion) {\n        selected = unselected.filter((box) => predicate(box) || inclusion.has(box.boxId));\n      } else {\n        selected = unselected.filter(predicate);\n      }\n    } else if (inclusion) {\n      selected = unselected.filter((box) => inclusion.has(box.boxId));\n    }\n\n    if (some(selected)) {\n      unselected = unselected.filter(\n        (box) => !selected.some((sel) => sel.boxId === box.boxId)\n      );\n\n      if (remaining.nanoErgs && remaining.nanoErgs > _0n) {\n        remaining.nanoErgs -= sumBy(selected, (input) => input.value);\n      }\n\n      if (some(remaining.tokens) && selected.some((input) => !isEmpty(input.assets))) {\n        for (const t of remaining.tokens) {\n          if (t.amount && t.amount > _0n) {\n            t.amount -= utxoSum(selected, t.tokenId);\n          }\n        }\n      }\n    }\n\n    if (this._selector) {\n      unselected = orderBy(unselected, this._selector, this._sortDirection || \"asc\");\n    }\n\n    selected = selected.concat(this._strategy.select(unselected, remaining));\n\n    if (hasDuplicatesBy(selected, (item) => item.boxId)) {\n      throw new DuplicateInputSelectionError();\n    }\n\n    const unreached = this._getUnreachedTargets(selected, target);\n    if (unreached.nanoErgs || some(unreached.tokens)) {\n      throw new InsufficientInputs(unreached);\n    }\n\n    return selected as T[];\n  }\n\n  private _deepCloneTarget(target: SelectionTarget): SelectionTarget {\n    return {\n      nanoErgs: target.nanoErgs,\n      tokens: target.tokens\n        ? target.tokens.map((t) => ({ tokenId: t.tokenId, amount: t.amount }))\n        : undefined\n    };\n  }\n\n  private _getUnreachedTargets(\n    inputs: Box<bigint>[],\n    target: SelectionTarget\n  ): SelectionTarget {\n    const unreached: SelectionTarget = {\n      nanoErgs: undefined,\n      tokens: undefined\n    };\n    const selectedNanoergs = sumBy(inputs, (input) => input.value);\n\n    if (target.nanoErgs && target.nanoErgs > selectedNanoergs) {\n      unreached.nanoErgs = target.nanoErgs - selectedNanoergs;\n    }\n\n    if (isEmpty(target.tokens)) {\n      return unreached;\n    }\n\n    for (const tokenTarget of target.tokens) {\n      const totalSelected = utxoSum(inputs, tokenTarget.tokenId);\n      if (tokenTarget.amount && tokenTarget.amount > totalSelected) {\n        if (tokenTarget.tokenId === first(inputs).boxId) {\n          // if the token is the same as the first input, then it is being minted\n          continue;\n        }\n\n        if (isUndefined(unreached.tokens)) {\n          unreached.tokens = [];\n        }\n\n        unreached.tokens.push({\n          tokenId: tokenTarget.tokenId,\n          amount: tokenTarget.amount - totalSelected\n        });\n      }\n    }\n\n    return unreached;\n  }\n\n  public ensureInclusion(predicate: FilterPredicate<Box<bigint>>): BoxSelector<T>;\n  public ensureInclusion(boxIds: OneOrMore<BoxId>): BoxSelector<T>;\n  public ensureInclusion(filter: \"all\"): BoxSelector<T>;\n  public ensureInclusion(\n    predicateOrBoxIds: FilterPredicate<Box<bigint>> | OneOrMore<BoxId> | \"all\"\n  ): BoxSelector<T> {\n    if (typeof predicateOrBoxIds === \"function\") {\n      this._ensureFilterPredicate = predicateOrBoxIds;\n    } else if (predicateOrBoxIds === \"all\") {\n      this._ensureFilterPredicate = (box) => box.value > 0n;\n    } else {\n      if (isUndefined(this._ensureInclusionBoxIds)) {\n        this._ensureInclusionBoxIds = new Set();\n      }\n\n      if (Array.isArray(predicateOrBoxIds)) {\n        for (const boxId of predicateOrBoxIds) {\n          this._ensureInclusionBoxIds.add(boxId);\n        }\n      } else {\n        this._ensureInclusionBoxIds.add(predicateOrBoxIds);\n      }\n    }\n\n    return this;\n  }\n\n  public orderBy(\n    selector: SortingSelector<Box<bigint>>,\n    direction?: SortingDirection\n  ): BoxSelector<T> {\n    this._selector = selector;\n    this._sortDirection = direction;\n\n    return this;\n  }\n\n  private _isISelectionStrategyImplementation(obj: unknown): obj is ISelectionStrategy {\n    if ((obj as ISelectionStrategy).select) {\n      return true;\n    }\n\n    return false;\n  }\n\n  public static buildTargetFrom(\n    boxes: Box<Amount>[] | BoxCandidate<Amount>[]\n  ): SelectionTarget {\n    const tokens: { [tokenId: string]: bigint } = {};\n    let nanoErgs = _0n;\n\n    for (const box of boxes) {\n      nanoErgs += ensureBigInt(box.value);\n      for (const token of box.assets) {\n        tokens[token.tokenId] =\n          (tokens[token.tokenId] || _0n) + ensureBigInt(token.amount);\n      }\n    }\n\n    return {\n      nanoErgs,\n      tokens: Object.keys(tokens).map((tokenId) => ({\n        tokenId,\n        amount: tokens[tokenId]\n      }))\n    };\n  }\n}\n","import { type Box, orderBy } from \"@fleet-sdk/common\";\nimport type { SelectionTarget } from \"../boxSelector\";\nimport { AccumulativeSelectionStrategy } from \"./accumulativeSelectionStrategy\";\n\n/**\n * The Cherry Pick strategy accumulates inputs until the target amounts trying\n * to pick inputs with as less as possible unused tokens.\n */\nexport class CherryPickSelectionStrategy extends AccumulativeSelectionStrategy {\n  public override select(inputs: Box<bigint>[], target: SelectionTarget): Box<bigint>[] {\n    const orderedInputs = orderBy(\n      inputs,\n      (x) => new Set(x.assets.map((asset) => asset.tokenId)).size,\n      \"asc\"\n    );\n\n    return super.select(orderedInputs, target);\n  }\n}\n","export class DuplicateInputError extends Error {\n  constructor(boxId: string) {\n    super(`Box '${boxId}' is already included.`);\n  }\n}\n","export class InsufficientTokenAmount extends Error {}\n","export class InvalidAddress extends Error {\n  constructor(address: string) {\n    super(`Invalid Ergo address: ${address}`);\n  }\n}\n","export class InvalidInput extends Error {\n  constructor(boxId: string) {\n    super(`Invalid input: ${boxId}`);\n  }\n}\n","export class InvalidRegistersPacking extends Error {\n  constructor() {\n    super(\n      `Registers should be densely packed. This means that it's not possible to use a register like 'R7' without filling 'R6', 'R5' and 'R4', for example.`\n    );\n  }\n}\n","export class MalformedTransaction extends Error {\n  constructor(message: string) {\n    super(`Malformed transaction: ${message}`);\n  }\n}\n","import {\n  type Amount,\n  Collection,\n  type CollectionAddOptions,\n  FleetError,\n  isDefined,\n  isUndefined,\n  type NewToken,\n  type OneOrMore,\n  type TokenAmount,\n  type TokenId\n} from \"@fleet-sdk/common\";\nimport { ensureBigInt } from \"@fleet-sdk/common\";\nimport { NotFoundError, UndefinedMintingContext } from \"../../errors\";\nimport { InsufficientTokenAmount } from \"../../errors/insufficientTokenAmount\";\nimport { MaxTokensOverflow } from \"../../errors/maxTokensOverflow\";\n\nexport const MAX_TOKENS_PER_BOX = 100;\n\nexport type TokenAddOptions = CollectionAddOptions & { sum?: boolean };\nexport type OutputToken<T extends Amount = Amount> = {\n  tokenId?: TokenId;\n  amount: T;\n};\n\ntype MintingData = { index: number; metadata: NewToken<Amount> };\n\nexport class TokensCollection extends Collection<OutputToken<bigint>, OutputToken> {\n  #minting: MintingData | undefined;\n\n  constructor();\n  constructor(token: TokenAmount<Amount>);\n  constructor(tokens: TokenAmount<Amount>[]);\n  constructor(tokens: TokenAmount<Amount>[], options: TokenAddOptions);\n  constructor(tokens?: OneOrMore<TokenAmount<Amount>>, options?: TokenAddOptions) {\n    super();\n\n    if (isDefined(tokens)) {\n      this.add(tokens, options);\n    }\n  }\n\n  public get minting(): NewToken<bigint> | undefined {\n    if (!this.#minting) return undefined;\n    return {\n      ...this.#minting.metadata,\n      amount: this._items[this.#minting.index].amount\n    };\n  }\n\n  protected override _map(token: OutputToken): OutputToken<bigint> {\n    return { tokenId: token.tokenId, amount: ensureBigInt(token.amount) };\n  }\n\n  protected override _addOne(token: OutputToken, options?: TokenAddOptions): number {\n    if (isUndefined(options) || (options.sum && isUndefined(options.index))) {\n      if (this._sum(this._map(token))) return this.length;\n    }\n\n    if (this._items.length >= MAX_TOKENS_PER_BOX) throw new MaxTokensOverflow();\n    super._addOne(token, options);\n\n    return this.length;\n  }\n\n  public override add(\n    items: OneOrMore<TokenAmount<Amount>>,\n    options?: TokenAddOptions\n  ): number {\n    if (Array.isArray(items)) {\n      if (items.some((x) => !x.tokenId)) throw new FleetError(\"TokenID is required.\");\n    } else if (!items.tokenId) {\n      throw new FleetError(\"TokenID is required.\");\n    }\n\n    return super.add(items, options);\n  }\n\n  public mint(token: NewToken<Amount>): number {\n    if (isDefined(this.#minting)) {\n      throw new FleetError(\"Only one minting token is allowed per transaction.\");\n    }\n\n    const len = super.add({ tokenId: token.tokenId, amount: token.amount });\n    this.#minting = { index: len - 1, metadata: token };\n    return this.length;\n  }\n\n  private _sum(token: OutputToken<bigint>): boolean {\n    for (const t of this._items) {\n      if (t.tokenId === token.tokenId) {\n        t.amount += token.amount;\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public remove(tokenId: TokenId, amount?: Amount): number;\n  public remove(index: number, amount?: Amount): number;\n  public remove(tokenIdOrIndex: TokenId | number, amount?: Amount): number {\n    let index = -1;\n    if (typeof tokenIdOrIndex === \"number\") {\n      if (this._isIndexOutOfBounds(tokenIdOrIndex)) {\n        throw new RangeError(`Index '${tokenIdOrIndex}' is out of range.`);\n      }\n\n      index = tokenIdOrIndex;\n    } else {\n      index = this._items.findIndex((token) => token.tokenId === tokenIdOrIndex);\n\n      if (this._isIndexOutOfBounds(index)) {\n        throw new NotFoundError(\n          `TokenId '${tokenIdOrIndex}' not found in assets collection.`\n        );\n      }\n    }\n\n    if (amount && index > -1) {\n      const bigAmount = ensureBigInt(amount);\n      const token = this._items[index];\n\n      if (bigAmount > token.amount) {\n        throw new InsufficientTokenAmount(\n          \"Insufficient token amount to perform a subtraction operation.\"\n        );\n      }\n\n      if (bigAmount < token.amount) {\n        token.amount -= bigAmount;\n        return this.length;\n      }\n    }\n\n    this._items.splice(index, 1);\n    return this.length;\n  }\n\n  contains(tokenId: string): boolean {\n    return this._items.some((x) => x.tokenId === tokenId);\n  }\n\n  toArray(): TokenAmount<bigint>[];\n  toArray(mintingTokenId: string): TokenAmount<bigint>[];\n  toArray(mintingTokenId?: string): TokenAmount<bigint>[];\n  toArray(mintingTokenId?: string): OutputToken[] {\n    if (this.minting) {\n      if (!mintingTokenId) throw new UndefinedMintingContext();\n\n      return this._items.map((x) => ({\n        tokenId: x.tokenId ? x.tokenId : mintingTokenId,\n        amount: x.amount\n      }));\n    }\n\n    return super.toArray();\n  }\n}\n","import { MAX_TOKENS_PER_BOX } from \"../models/collections/tokensCollection\";\n\nexport class MaxTokensOverflow extends Error {\n  constructor() {\n    super(`A box must contain no more than ${MAX_TOKENS_PER_BOX} distinct tokens.`);\n  }\n}\n","export class NotAllowedTokenBurning extends Error {\n  constructor() {\n    super(\n      \"This transaction is trying to burn tokens. If that's your intention you must explicitly allow token burning on TransactionBuilder.configure() method. If no, a change address should be provided.\"\n    );\n  }\n}\n","export class NotFoundError extends Error {}\n","export class UndefinedCreationHeight extends Error {\n  constructor() {\n    super(\n      \"Minting context is undefined. Transaction's inputs must be included in order to determine minting token id.\"\n    );\n  }\n}\n","export class UndefinedMintingContext extends Error {\n  constructor() {\n    super(\"Creation Height is undefined.\");\n  }\n}\n","import {\n  AddressType,\n  areEqual,\n  type Base58String,\n  concatBytes,\n  first,\n  isEmpty,\n  type Network\n} from \"@fleet-sdk/common\";\nimport { base58, blake2b256, validateEcPoint } from \"@fleet-sdk/crypto\";\nimport { SigmaByteWriter } from \"@fleet-sdk/serializer\";\n\nexport const CHECKSUM_LENGTH = 4;\nexport const BLAKE_256_HASH_LENGTH = 32;\n\nexport type UnpackedAddress = {\n  head: Uint8Array;\n  body: Uint8Array;\n  checksum: Uint8Array;\n  network: Network;\n  type: AddressType;\n};\n\nexport function getNetworkType(addressBytes: Uint8Array): Network {\n  return first(addressBytes) & 0xf0;\n}\n\nexport function getAddressType(addressBytes: Uint8Array): AddressType {\n  return first(addressBytes) & 0x0f;\n}\n\n/**\n * Unpacks the given bytes into an UnpackedAddress object.\n *\n * @param bytes - The bytes to unpack.\n * @returns The UnpackedAddress object containing the unpacked data.\n */\nexport function unpackAddress(bytes: Uint8Array): UnpackedAddress {\n  return {\n    head: bytes.subarray(0, 1),\n    body: bytes.subarray(1, bytes.length - CHECKSUM_LENGTH),\n    checksum: bytes.subarray(bytes.length - CHECKSUM_LENGTH, bytes.length),\n    network: getNetworkType(bytes),\n    type: getAddressType(bytes)\n  };\n}\n\nexport function encodeAddress(\n  network: Network,\n  type: AddressType,\n  content: Uint8Array\n): Base58String {\n  return new SigmaByteWriter(1 /** head */ + content.length + CHECKSUM_LENGTH)\n    .write(network + type)\n    .writeBytes(content)\n    .writeChecksum(CHECKSUM_LENGTH)\n    .encode(base58);\n}\n\nexport function validateUnpackedAddress(unpacked: UnpackedAddress): boolean {\n  const content = concatBytes(unpacked.head, unpacked.body);\n  if (isEmpty(unpacked.body)) return false;\n  if (unpacked.type === AddressType.P2PK && !validateEcPoint(unpacked.body)) return false;\n\n  const checksum = blake2b256(content).subarray(0, CHECKSUM_LENGTH);\n  return areEqual(checksum, unpacked.checksum);\n}\n\n/**\n * Validates a Base58 encoded address.\n *\n * @param encodedAddress - The Base58 encoded address to validate.\n * @returns A boolean indicating whether the address is valid or not.\n */\nexport function validateAddress(encodedAddress: Base58String): boolean {\n  return validateUnpackedAddress(unpackAddress(base58.decode(encodedAddress)));\n}\n","import {\n  AddressType,\n  type Base58String,\n  type HexString,\n  Network\n} from \"@fleet-sdk/common\";\nimport { concatBytes, endsWith, first, startsWith } from \"@fleet-sdk/common\";\nimport {\n  base58,\n  blake2b256,\n  type ByteInput,\n  ensureBytes,\n  hex,\n  validateEcPoint\n} from \"@fleet-sdk/crypto\";\nimport { InvalidAddress } from \"../errors/invalidAddress\";\nimport {\n  BLAKE_256_HASH_LENGTH,\n  encodeAddress,\n  getAddressType,\n  getNetworkType,\n  unpackAddress,\n  type UnpackedAddress,\n  validateAddress,\n  validateUnpackedAddress\n} from \"./utils\";\n\nconst P2PK_ERGOTREE_PREFIX = hex.decode(\"0008cd\");\nconst P2PK_ERGOTREE_LENGTH = 36;\n\nconst P2SH_ERGOTREE_SUFFIX = hex.decode(\"d40801\");\nconst P2SH_ERGOTREE_PREFIX = hex.decode(\"00ea02d193b4cbe4e3010e040004300e18\");\nconst P2SH_ERGOTREE_LENGTH = 44;\nconst P2SH_HASH_LENGTH = 24;\n\nfunction getErgoTreeType(ergoTree: Uint8Array): AddressType {\n  if (\n    ergoTree.length === P2PK_ERGOTREE_LENGTH &&\n    startsWith(ergoTree, P2PK_ERGOTREE_PREFIX)\n  ) {\n    return AddressType.P2PK;\n  }\n\n  if (\n    ergoTree.length === P2SH_ERGOTREE_LENGTH &&\n    startsWith(ergoTree, P2SH_ERGOTREE_PREFIX) &&\n    endsWith(ergoTree, P2SH_ERGOTREE_SUFFIX)\n  ) {\n    return AddressType.P2SH;\n  }\n\n  return AddressType.P2S;\n}\n\n/**\n * Ergo address model\n *\n * @example\n * Convert address to ErgoTree hex string\n * ```\n * const address = new Address(\"9eZ24iqjKywjzAti9RnWWTR3CiNnLJDAcd2MenKodcAfzc8AFTu\");\n * console.log(address.ergoTree);\n * ```\n *\n * @example\n * Convert ErgoTree hex string to address string\n * ```\n * const ergoTree = \"0008cd026dc059d64a50d0dbf07755c2c4a4e557e3df8afa7141868b3ab200643d437ee7\"\n * const address = Address.fromErgoTree(ergoTree).toString();\n * ```\n */\nexport class ErgoAddress {\n  #ergoTree: Uint8Array;\n  #network: Network;\n  #type: AddressType;\n\n  public get network(): Network {\n    return this.#network;\n  }\n\n  /**\n   * ErgoTree hex string\n   */\n  public get ergoTree(): HexString {\n    return hex.encode(this.#ergoTree);\n  }\n\n  public get type(): AddressType {\n    return this.#type;\n  }\n\n  /**\n   * New instance from ErgoTree bytes\n   * @param ergoTree ErgoTree bytes\n   */\n  public constructor(ergoTree: Uint8Array, network: Network = Network.Mainnet) {\n    this.#ergoTree = ergoTree;\n    this.#network = network;\n    this.#type = getErgoTreeType(ergoTree);\n  }\n\n  /**\n   * Create a new instance from an ErgoTree\n   * @param ergoTree ErgoTree hex string\n   */\n  public static fromErgoTree(ergoTree: ByteInput, network?: Network): ErgoAddress {\n    return new ErgoAddress(ensureBytes(ergoTree), network);\n  }\n\n  /**\n   * Create a new instance from a public key\n   * @param publicKey Public key hex string\n   */\n  public static fromPublicKey(publicKey: ByteInput, network?: Network): ErgoAddress {\n    const bytes = ensureBytes(publicKey);\n    if (!validateEcPoint(bytes)) throw new Error(\"The Public Key is invalid.\");\n\n    const ergoTree = concatBytes(P2PK_ERGOTREE_PREFIX, bytes);\n    return new ErgoAddress(ergoTree, network);\n  }\n\n  public static fromHash(hash: HexString | Uint8Array, network?: Network): ErgoAddress {\n    let bytes = ensureBytes(hash);\n\n    if (bytes.length === BLAKE_256_HASH_LENGTH) {\n      bytes = bytes.subarray(0, P2SH_HASH_LENGTH);\n    } else if (bytes.length !== P2SH_HASH_LENGTH) {\n      throw Error(`Invalid hash length: ${bytes.length}`);\n    }\n\n    const ergoTree = concatBytes(P2SH_ERGOTREE_PREFIX, bytes, P2SH_ERGOTREE_SUFFIX);\n\n    return new ErgoAddress(ergoTree, network);\n  }\n\n  /**\n   * Create a new checked instance from an address string\n   * @param encodedAddress Address encoded as base58\n   */\n  public static decode(encodedAddress: Base58String): ErgoAddress {\n    const bytes = base58.decode(encodedAddress);\n    const unpacked = unpackAddress(bytes);\n    if (!validateUnpackedAddress(unpacked)) throw new InvalidAddress(encodedAddress);\n\n    return ErgoAddress.#fromUnpacked(unpacked);\n  }\n\n  public static decodeUnsafe(encodedAddress: Base58String): ErgoAddress {\n    return ErgoAddress.#fromUnpacked(unpackAddress(base58.decode(encodedAddress)));\n  }\n\n  static fromBase58(address: Base58String, unsafe = false): ErgoAddress {\n    return unsafe ? ErgoAddress.decodeUnsafe(address) : ErgoAddress.decode(address);\n  }\n\n  static #fromUnpacked(unpacked: UnpackedAddress) {\n    switch (unpacked.type) {\n      case AddressType.P2PK:\n        return ErgoAddress.fromPublicKey(unpacked.body, unpacked.network);\n      case AddressType.P2SH:\n        return ErgoAddress.fromHash(unpacked.body, unpacked.network);\n      case AddressType.ADH:\n        throw new Error(\"Invalid address type\");\n      default:\n        return new ErgoAddress(unpacked.body, unpacked.network);\n    }\n  }\n\n  /**\n   * Validate an address\n   * @param address Address bytes or string\n   * @deprecated Use `validateAddress()` function instead\n   */\n  public static validate(address: Base58String): boolean {\n    return validateAddress(address);\n  }\n\n  public static getNetworkType(address: Base58String): Network {\n    return getNetworkType(base58.decode(address));\n  }\n\n  public static getAddressType(address: Base58String): AddressType {\n    return getAddressType(base58.decode(address));\n  }\n\n  public getPublicKeys(): Uint8Array[] {\n    if (this.type === AddressType.P2PK) {\n      return [this.#ergoTree.subarray(P2PK_ERGOTREE_PREFIX.length)];\n    }\n\n    return [];\n  }\n\n  public toP2SH(network?: Network): Base58String {\n    if (this.type === AddressType.P2SH) return this.encode();\n\n    const hash = blake2b256(this.#ergoTree).subarray(0, P2SH_HASH_LENGTH);\n    return encodeAddress(network ?? this.#network, AddressType.P2SH, hash);\n  }\n\n  /**\n   * Encode address as base58 string\n   */\n  public encode(network?: Network): Base58String {\n    let body: Uint8Array;\n    if (this.type === AddressType.P2PK) {\n      body = first(this.getPublicKeys());\n    } else if (this.type === AddressType.P2SH) {\n      body = this.#ergoTree.subarray(\n        P2SH_ERGOTREE_PREFIX.length,\n        P2SH_ERGOTREE_PREFIX.length + P2SH_HASH_LENGTH\n      );\n    } else {\n      body = this.#ergoTree;\n    }\n\n    return encodeAddress(network ?? this.#network, this.#type, body);\n  }\n\n  /**\n   * Encode address as base58 string\n   */\n  public toString(network?: Network): Base58String {\n    return this.encode(network ?? this.#network);\n  }\n}\n","import type { Amount, Box, NonMandatoryRegisters, TokenAmount } from \"@fleet-sdk/common\";\nimport { ensureBigInt } from \"@fleet-sdk/common\";\nimport { blake2b256, hex } from \"@fleet-sdk/crypto\";\nimport { serializeBox } from \"@fleet-sdk/serializer\";\n\nexport class ErgoBox<R extends NonMandatoryRegisters = NonMandatoryRegisters> {\n  boxId!: string;\n  value!: bigint;\n  ergoTree!: string;\n  creationHeight!: number;\n  assets!: TokenAmount<bigint>[];\n  additionalRegisters!: R;\n  transactionId!: string;\n  index!: number;\n\n  constructor(box: Box<Amount, R>) {\n    this.boxId = box.boxId;\n    this.ergoTree = box.ergoTree;\n    this.creationHeight = box.creationHeight;\n    this.value = ensureBigInt(box.value);\n    this.assets = box.assets.map((asset) => ({\n      tokenId: asset.tokenId,\n      amount: ensureBigInt(asset.amount)\n    }));\n    this.additionalRegisters = box.additionalRegisters;\n    this.transactionId = box.transactionId;\n    this.index = box.index;\n  }\n\n  public isValid(): boolean {\n    return ErgoBox.validate(this);\n  }\n\n  static validate(box: Box<Amount> | ErgoBox): boolean {\n    const bytes = serializeBox(box).toBytes();\n    const hash = hex.encode(blake2b256(bytes));\n\n    return box.boxId === hash;\n  }\n}\n","import type {\n  Amount,\n  Box,\n  BuildOutputType,\n  ContextExtension,\n  DataInput,\n  EIP12UnsignedDataInput,\n  EIP12UnsignedInput,\n  NonMandatoryRegisters,\n  UnsignedInput\n} from \"@fleet-sdk/common\";\nimport type { ConstantInput } from \"../builder\";\nimport { ErgoBox } from \"./ergoBox\";\n\ntype InputType<T> = T extends \"default\" ? UnsignedInput : EIP12UnsignedInput;\ntype DataInputType<T> = T extends \"default\" ? DataInput : EIP12UnsignedDataInput;\ntype InputBox<R extends NonMandatoryRegisters> = Box<Amount, R> & {\n  extension?: ContextExtension;\n};\ntype ContextExtensionInput = ContextExtension<ConstantInput>;\n\nexport class ErgoUnsignedInput<\n  R extends NonMandatoryRegisters = NonMandatoryRegisters\n> extends ErgoBox<R> {\n  #extension?: ContextExtension;\n\n  public get extension(): ContextExtension | undefined {\n    return this.#extension;\n  }\n\n  constructor(box: InputBox<R>) {\n    super(box);\n\n    if (box.extension) {\n      this.setContextVars(box.extension);\n    }\n  }\n\n  public setContextExtension(extension: ContextExtensionInput): ErgoUnsignedInput {\n    const vars: ContextExtension = {};\n    for (const key in extension) {\n      const c = extension[key] as ConstantInput;\n      if (!c) continue;\n\n      vars[key as unknown as keyof ContextExtension] =\n        typeof c === \"string\" ? c : c.toHex();\n    }\n\n    this.#extension = vars;\n\n    return this;\n  }\n\n  /**\n   * @deprecated use `setContextExtension` instead.\n   */\n  public setContextVars(extension: ContextExtensionInput): ErgoUnsignedInput {\n    return this.setContextExtension(extension);\n  }\n\n  public toUnsignedInputObject<T extends BuildOutputType>(type: T): InputType<T> {\n    return {\n      ...this.toPlainObject(type),\n      extension: this.#extension || {}\n    } as InputType<T>;\n  }\n\n  public toPlainObject<T extends BuildOutputType>(type: T): DataInputType<T> {\n    if (type === \"EIP-12\") {\n      return {\n        boxId: this.boxId,\n        value: this.value.toString(),\n        ergoTree: this.ergoTree,\n        creationHeight: this.creationHeight,\n        assets: this.assets.map((asset) => ({\n          tokenId: asset.tokenId,\n          amount: asset.amount.toString()\n        })),\n        additionalRegisters: this.additionalRegisters,\n        transactionId: this.transactionId,\n        index: this.index\n      } as DataInputType<T>;\n    }\n\n    return { boxId: this.boxId } as DataInputType<T>;\n  }\n}\n","import {\n  type BoxCandidate,\n  type BoxSummary,\n  type BuildOutputType,\n  type EIP12UnsignedTransaction,\n  type UnsignedTransaction,\n  utxoDiff,\n  utxoSum\n} from \"@fleet-sdk/common\";\nimport { blake2b256, hex } from \"@fleet-sdk/crypto\";\nimport { serializeTransaction } from \"@fleet-sdk/serializer\";\nimport type { ErgoUnsignedInput } from \"./ergoUnsignedInput\";\n\ntype Input = ErgoUnsignedInput;\ntype Output = BoxCandidate<bigint>;\ntype ReadOnlyInputs = readonly Input[];\ntype ReadOnlyOutputs = readonly Output[];\n\ntype TransactionType<T> = T extends \"default\"\n  ? UnsignedTransaction\n  : EIP12UnsignedTransaction;\n\nexport class ErgoUnsignedTransaction {\n  private readonly _inputs!: ReadOnlyInputs;\n  private readonly _dataInputs!: ReadOnlyInputs;\n  private readonly _outputs!: ReadOnlyOutputs;\n\n  constructor(inputs: Input[], dataInputs: Input[], outputs: Output[]) {\n    this._inputs = Object.freeze(inputs);\n    this._dataInputs = Object.freeze(dataInputs);\n    this._outputs = Object.freeze(outputs);\n  }\n\n  get id(): string {\n    return hex.encode(blake2b256(this.toBytes()));\n  }\n\n  get inputs(): ReadOnlyInputs {\n    return this._inputs;\n  }\n\n  get dataInputs(): ReadOnlyInputs {\n    return this._dataInputs;\n  }\n\n  get outputs(): ReadOnlyOutputs {\n    return this._outputs;\n  }\n\n  get burning(): BoxSummary {\n    const diff = utxoDiff(utxoSum(this.inputs), utxoSum(this.outputs));\n    if (diff.tokens.length > 0) {\n      diff.tokens = diff.tokens.filter((x) => x.tokenId !== this.inputs[0].boxId);\n    }\n\n    return diff;\n  }\n\n  toPlainObject(): UnsignedTransaction;\n  toPlainObject<T extends BuildOutputType>(outputType: T): TransactionType<T>;\n  toPlainObject<T extends BuildOutputType>(outputType?: T): TransactionType<T> {\n    return {\n      inputs: this.inputs.map((input) =>\n        input.toUnsignedInputObject(outputType || \"default\")\n      ),\n      dataInputs: this.dataInputs.map((input) =>\n        input.toPlainObject(outputType || \"default\")\n      ),\n      outputs: this.outputs.map((output) => _stringifyBoxAmounts(output))\n    } as TransactionType<T>;\n  }\n\n  toEIP12Object(): EIP12UnsignedTransaction {\n    return this.toPlainObject(\"EIP-12\");\n  }\n\n  toBytes(): Uint8Array {\n    return serializeTransaction({\n      inputs: this.inputs.map((input) => input.toUnsignedInputObject(\"default\")),\n      dataInputs: this.dataInputs.map((input) => input.toPlainObject(\"default\")),\n      outputs: this.outputs\n    }).toBytes();\n  }\n}\n\nfunction _stringifyBoxAmounts<T>(output: BoxCandidate<bigint>): T {\n  return {\n    ...output,\n    value: output.value.toString(),\n    assets: output.assets.map((token) => ({\n      tokenId: token.tokenId,\n      amount: token.amount.toString()\n    }))\n  } as T;\n}\n","import {\n  type Amount,\n  type Box,\n  type BoxId,\n  Collection,\n  type OneOrMore\n} from \"@fleet-sdk/common\";\nimport { isDefined } from \"@fleet-sdk/common\";\nimport { DuplicateInputError, NotFoundError } from \"../../errors\";\nimport { ErgoUnsignedInput } from \"../ergoUnsignedInput\";\n\nexport class InputsCollection extends Collection<ErgoUnsignedInput, Box<Amount>> {\n  constructor();\n  constructor(box: Box<Amount>);\n  constructor(boxes: Box<Amount>[]);\n  constructor(boxes?: OneOrMore<Box<Amount>>) {\n    super();\n\n    if (isDefined(boxes)) {\n      this.add(boxes);\n    }\n  }\n\n  protected override _map(input: Box<Amount> | ErgoUnsignedInput): ErgoUnsignedInput {\n    return input instanceof ErgoUnsignedInput ? input : new ErgoUnsignedInput(input);\n  }\n\n  protected override _addOne(box: Box<Amount>): number {\n    if (this._items.some((item) => item.boxId === box.boxId)) {\n      throw new DuplicateInputError(box.boxId);\n    }\n\n    return super._addOne(box);\n  }\n\n  public remove(boxId: BoxId): number;\n  public remove(index: number): number;\n  public remove(boxIdOrIndex: BoxId | number): number {\n    let index = -1;\n    if (typeof boxIdOrIndex === \"number\") {\n      if (this._isIndexOutOfBounds(boxIdOrIndex)) {\n        throw new RangeError(`Index '${boxIdOrIndex}' is out of range.`);\n      }\n\n      index = boxIdOrIndex;\n    } else {\n      index = this._items.findIndex((box) => box.boxId === boxIdOrIndex);\n\n      if (this._isIndexOutOfBounds(index)) {\n        throw new NotFoundError(\n          \"The input you are trying to remove is not present in the inputs collection.\"\n        );\n      }\n    }\n\n    this._items.splice(index, 1);\n\n    return this.length;\n  }\n}\n","import {\n  _0n,\n  type BoxSummary,\n  Collection,\n  isDefined,\n  isUndefined,\n  type OneOrMore,\n  some\n} from \"@fleet-sdk/common\";\nimport type { OutputBuilder } from \"../../builder/outputBuilder\";\nimport type { SelectionTarget } from \"../../builder/selector/boxSelector\";\nimport { NotFoundError } from \"../../errors\";\n\nfunction setSum<K>(map: Map<K, bigint>, key: K, value: bigint) {\n  return map.set(key, (map.get(key) || _0n) + value);\n}\n\nexport class OutputsCollection extends Collection<OutputBuilder, OutputBuilder> {\n  constructor(outputs?: OneOrMore<OutputBuilder>) {\n    super();\n\n    if (isDefined(outputs)) {\n      this.add(outputs);\n    }\n  }\n\n  protected _map(output: OutputBuilder) {\n    return output;\n  }\n\n  remove(output: OutputBuilder): number;\n  remove(index: number): number;\n  remove(outputs: OutputBuilder | number): number {\n    let index = -1;\n    if (typeof outputs === \"number\") {\n      if (this._isIndexOutOfBounds(outputs)) {\n        throw new RangeError(`Index '${outputs}' is out of range.`);\n      }\n\n      index = outputs;\n    } else {\n      index = this._items.lastIndexOf(outputs);\n\n      if (this._isIndexOutOfBounds(index)) {\n        throw new NotFoundError(\n          \"The output you are trying to remove is not present in the outputs collection.\"\n        );\n      }\n    }\n\n    this._items.splice(index, 1);\n\n    return this.length;\n  }\n\n  clone(): OutputsCollection {\n    return new OutputsCollection(this._items);\n  }\n\n  sum(basis?: SelectionTarget | BoxSummary): BoxSummary {\n    const tokens = new Map<string, bigint>();\n    let nanoErgs = _0n;\n\n    if (basis) {\n      if (basis.nanoErgs) {\n        nanoErgs = basis.nanoErgs;\n      }\n\n      if (some(basis.tokens)) {\n        for (const token of basis.tokens) {\n          if (isUndefined(token.amount)) continue;\n\n          setSum(tokens, token.tokenId, token.amount);\n        }\n      }\n    }\n\n    for (const box of this._items) {\n      nanoErgs += box.value;\n      for (const token of box.assets) {\n        if (token.tokenId) setSum(tokens, token.tokenId, token.amount);\n      }\n    }\n\n    return {\n      nanoErgs,\n      tokens: Array.from(tokens, ([tokenId, amount]) => ({ tokenId, amount }))\n    };\n  }\n}\n","import { ergoTreeHeaderFlags, type HexString, Network } from \"@fleet-sdk/common\";\nimport { hex } from \"@fleet-sdk/crypto\";\nimport { ErgoAddress } from \"./ergoAddress\";\n\nconst VERSION_MASK = 0x07;\n\nexport class ErgoTree {\n  private _bytes: Uint8Array;\n\n  constructor(input: HexString | Uint8Array) {\n    if (typeof input === \"string\") {\n      this._bytes = hex.decode(input);\n    } else {\n      this._bytes = input;\n    }\n  }\n\n  get header(): number {\n    return this._bytes[0];\n  }\n\n  get version(): number {\n    return this.header & VERSION_MASK;\n  }\n\n  get hasSegregatedConstants(): boolean {\n    return (this.header & ergoTreeHeaderFlags.constantSegregation) !== 0;\n  }\n\n  get hasSize(): boolean {\n    return (this.header & ergoTreeHeaderFlags.sizeInclusion) !== 0;\n  }\n\n  toBytes(): Uint8Array {\n    return this._bytes;\n  }\n\n  toHex(): HexString {\n    return hex.encode(this.toBytes());\n  }\n\n  toAddress(network = Network.Mainnet): ErgoAddress {\n    return ErgoAddress.fromErgoTree(this.toHex(), network);\n  }\n}\n","import {\n  AddressType,\n  areEqual,\n  type Base58String,\n  isHex,\n  Network\n} from \"@fleet-sdk/common\";\nimport {\n  base58,\n  blake2b256,\n  type ByteInput,\n  ensureBytes,\n  hex,\n  utf8\n} from \"@fleet-sdk/crypto\";\nimport { SigmaByteWriter } from \"@fleet-sdk/serializer\";\nimport type { JsonObject, JsonValue } from \"type-fest\";\nimport { encodeAddress, unpackAddress, validateUnpackedAddress } from \"./utils\";\n\nconst SERIALIZED_HASH_LENGTH = 34; // invalidation byte (1) + network type (1) + hash (32)\n\nexport type NetworkOptions = {\n  network?: Network;\n};\n\nexport type ErgoMessageFromHashOptions = NetworkOptions & {\n  hash: ByteInput;\n};\n\nexport type MessageData = Uint8Array | JsonValue | JsonObject;\n\nexport type ErgoMessageFromDataOptions = NetworkOptions & {\n  data: MessageData;\n};\n\nexport type ErgoMessageOptions = ErgoMessageFromHashOptions | ErgoMessageFromDataOptions;\n\nexport const MessageType = {\n  Hash: 0,\n  Binary: 1,\n  String: 2,\n  Json: 3\n} as const;\n\nexport type MessageType = (typeof MessageType)[keyof typeof MessageType];\n\nexport class ErgoMessage {\n  #data?: Uint8Array;\n  #type: MessageType;\n  #hash: Uint8Array;\n  #network: Network;\n\n  constructor(options: ErgoMessageOptions) {\n    if (\"data\" in options) {\n      [this.#data, this.#type] = this.#decodeData(options.data);\n      this.#hash = blake2b256(this.#data);\n    } else if (\"hash\" in options) {\n      this.#hash = ensureBytes(options.hash);\n      this.#type = MessageType.Hash;\n    } else {\n      throw new Error(\"Either hash or message data must be provided\");\n    }\n\n    this.#network = options.network ?? Network.Mainnet;\n  }\n\n  get hash(): Uint8Array {\n    return this.#hash;\n  }\n\n  get type(): MessageType {\n    return this.#type;\n  }\n\n  get network(): Network {\n    return this.#network;\n  }\n\n  #decodeData(data: MessageData): [Uint8Array, MessageType] {\n    if (typeof data === \"string\") {\n      return isHex(data)\n        ? [hex.decode(data), MessageType.Binary]\n        : [utf8.decode(data), MessageType.String];\n    }\n    if (data instanceof Uint8Array) return [data, MessageType.Binary];\n    return [utf8.decode(JSON.stringify(data)), MessageType.Json];\n  }\n\n  static decode(encodedHash: Base58String): ErgoMessage {\n    const unpacked = unpackAddress(base58.decode(encodedHash));\n    if (unpacked.type !== AddressType.ADH) throw new Error(\"Invalid message type\");\n    if (!validateUnpackedAddress(unpacked))\n      throw new Error(\"Invalid encoded message hash\");\n\n    return new ErgoMessage({ hash: unpacked.body, network: unpacked.network });\n  }\n\n  static fromBase58(encodedHash: Base58String): ErgoMessage {\n    return ErgoMessage.decode(encodedHash);\n  }\n\n  static fromData(data: MessageData, network?: Network): ErgoMessage {\n    return new ErgoMessage({ data, network });\n  }\n\n  encode(network?: Network): string {\n    return encodeAddress(network ?? this.#network, AddressType.ADH, this.hash);\n  }\n\n  toString(network?: Network): string {\n    return this.encode(network);\n  }\n\n  setNetwork(network: Network): ErgoMessage {\n    this.#network = network;\n    return this;\n  }\n\n  getData<T extends MessageData = MessageData>(): T | undefined {\n    if (!this.#data) return;\n    switch (this.#type) {\n      case MessageType.String:\n        return utf8.encode(this.#data) as T;\n      case MessageType.Json:\n        return JSON.parse(utf8.encode(this.#data)) as T;\n      default:\n        return this.#data as T;\n    }\n  }\n\n  serialize(): SigmaByteWriter {\n    return new SigmaByteWriter(SERIALIZED_HASH_LENGTH)\n      .write(0x0) // invalidation byte, see: https://github.com/ergoplatform/eips/blob/master/eip-0044.md#why-prefix-it-with-0x0\n      .write(this.#network)\n      .writeBytes(this.#hash);\n  }\n\n  verify(message: MessageData): boolean {\n    const [data] = this.#decodeData(message);\n    return areEqual(this.#hash, blake2b256(data));\n  }\n}\n","import {\n  _0n,\n  _1n,\n  type Amount,\n  areRegistersDenselyPacked,\n  assert,\n  type Box,\n  type BoxCandidate,\n  ensureBigInt,\n  type ErgoTreeHex,\n  type HexString,\n  isDefined,\n  isEmpty,\n  isHex,\n  isUndefined,\n  type NewToken,\n  type NonMandatoryRegisters,\n  type OneOrMore,\n  type TokenAmount,\n  type TokenId,\n  type UnsignedInput\n} from \"@fleet-sdk/common\";\nimport { utf8 } from \"@fleet-sdk/crypto\";\nimport { estimateBoxSize, SByte, SColl, type SConstant } from \"@fleet-sdk/serializer\";\nimport { InvalidRegistersPacking, UndefinedCreationHeight } from \"../errors\";\nimport { ErgoAddress, ErgoTree } from \"../models\";\nimport {\n  type TokenAddOptions,\n  TokensCollection\n} from \"../models/collections/tokensCollection\";\n\nexport const BOX_VALUE_PER_BYTE = BigInt(360);\nexport const SAFE_MIN_BOX_VALUE = BigInt(1000000);\n\nexport type BoxValueEstimationCallback = (outputBuilder: OutputBuilder) => bigint;\n\nexport function estimateMinBoxValue(\n  valuePerByte = BOX_VALUE_PER_BYTE\n): BoxValueEstimationCallback {\n  return (output) => {\n    return BigInt(output.estimateSize()) * valuePerByte;\n  };\n}\n\nconst DUMB_TOKEN_ID = \"0000000000000000000000000000000000000000000000000000000000000000\";\n\nexport class OutputBuilder {\n  private readonly _address: ErgoAddress;\n  private readonly _tokens: TokensCollection;\n  private _value!: bigint;\n  private _valueEstimator?: BoxValueEstimationCallback;\n  private _creationHeight?: number;\n  private _registers: NonMandatoryRegisters;\n\n  constructor(\n    value: Amount | BoxValueEstimationCallback,\n    recipient: ErgoAddress | ErgoTree | string,\n    creationHeight?: number\n  ) {\n    this.setValue(value);\n\n    this._creationHeight = creationHeight;\n    this._tokens = new TokensCollection();\n    this._registers = {};\n\n    if (typeof recipient === \"string\") {\n      this._address = isHex(recipient)\n        ? ErgoAddress.fromErgoTree(recipient)\n        : ErgoAddress.fromBase58(recipient);\n    } else if (recipient instanceof ErgoTree) {\n      this._address = recipient.toAddress();\n    } else {\n      this._address = recipient;\n    }\n  }\n\n  public get value(): bigint {\n    return isDefined(this._valueEstimator) ? this._valueEstimator(this) : this._value;\n  }\n\n  public get address(): ErgoAddress {\n    return this._address;\n  }\n\n  public get ergoTree(): ErgoTreeHex {\n    return this._address.ergoTree;\n  }\n\n  public get creationHeight(): number | undefined {\n    return this._creationHeight;\n  }\n\n  public get assets(): TokensCollection {\n    return this._tokens;\n  }\n\n  public get additionalRegisters(): NonMandatoryRegisters {\n    return this._registers;\n  }\n\n  public get minting(): NewToken<bigint> | undefined {\n    return this.assets.minting;\n  }\n\n  public setValue(value: Amount | BoxValueEstimationCallback): OutputBuilder {\n    if (typeof value === \"function\") {\n      this._valueEstimator = value;\n    } else {\n      this._value = ensureBigInt(value);\n      this._valueEstimator = undefined;\n\n      if (this._value <= _0n) {\n        throw new Error(\"An UTxO cannot be created without a minimum required amount.\");\n      }\n    }\n\n    return this;\n  }\n\n  public addTokens(\n    tokens: OneOrMore<TokenAmount<Amount>> | TokensCollection,\n    options?: TokenAddOptions\n  ): OutputBuilder {\n    if (tokens instanceof TokensCollection) {\n      this._tokens.add(tokens.toArray(), options);\n    } else {\n      this._tokens.add(tokens, options);\n    }\n\n    return this;\n  }\n\n  public addNfts(...tokenIds: TokenId[]): OutputBuilder {\n    const tokens = tokenIds.map((tokenId) => ({ tokenId, amount: _1n }));\n\n    return this.addTokens(tokens);\n  }\n\n  public mintToken(token: NewToken<Amount>): OutputBuilder {\n    this.assets.mint(token);\n    return this;\n  }\n\n  public setCreationHeight(\n    height: number,\n    options?: { replace: boolean }\n  ): OutputBuilder {\n    if (\n      isUndefined(options) ||\n      options.replace === true ||\n      (options.replace === false && isUndefined(this._creationHeight))\n    ) {\n      this._creationHeight = height;\n    }\n\n    return this;\n  }\n\n  public setAdditionalRegisters<T extends AdditionalRegistersInput>(\n    registers: SequentialNonMandatoryRegisters<T>\n  ): OutputBuilder {\n    const hexRegisters: NonMandatoryRegisters = {};\n    for (const key in registers) {\n      const r = registers[key] as ConstantInput;\n      if (!r) continue;\n\n      hexRegisters[key as keyof NonMandatoryRegisters] =\n        typeof r === \"string\" ? r : r.toHex();\n    }\n\n    if (!areRegistersDenselyPacked(hexRegisters)) throw new InvalidRegistersPacking();\n    this._registers = hexRegisters;\n\n    return this;\n  }\n\n  public eject(ejector: (context: { tokens: TokensCollection }) => void): OutputBuilder {\n    ejector({ tokens: this._tokens });\n    return this;\n  }\n\n  public build(\n    transactionInputs?: UnsignedInput[] | Box<Amount>[]\n  ): BoxCandidate<bigint> {\n    let tokens: TokenAmount<bigint>[];\n\n    if (this.minting) {\n      const mintingTokenId = transactionInputs ? transactionInputs[0]?.boxId : undefined;\n      tokens = this.assets.toArray(mintingTokenId);\n\n      if (isEmpty(this.additionalRegisters)) {\n        this.setAdditionalRegisters({\n          R4: SColl(SByte, utf8.decode(this.minting.name || \"\")),\n          R5: SColl(SByte, utf8.decode(this.minting.description || \"\")),\n          R6: SColl(SByte, utf8.decode(this.minting.decimals?.toString() || \"0\"))\n        });\n      }\n    } else {\n      tokens = this.assets.toArray();\n    }\n\n    if (isUndefined(this.creationHeight)) throw new UndefinedCreationHeight();\n\n    return {\n      value: this.value,\n      ergoTree: this.ergoTree,\n      creationHeight: this.creationHeight,\n      assets: tokens,\n      additionalRegisters: this.additionalRegisters\n    };\n  }\n\n  estimateSize(value = SAFE_MIN_BOX_VALUE): number {\n    assert(!!this.creationHeight, \"Creation height must be set\");\n\n    const plainBoxObject: BoxCandidate<bigint> = {\n      value,\n      ergoTree: this.ergoTree,\n      creationHeight: this.creationHeight,\n      assets: this._tokens.toArray(DUMB_TOKEN_ID),\n      additionalRegisters: this.additionalRegisters\n    };\n\n    return estimateBoxSize(plainBoxObject);\n  }\n}\n\nexport type ConstantInput = SConstant | HexString;\n\nexport type AdditionalRegistersInput = NonMandatoryRegisters<ConstantInput>;\n\nexport type OnlyR4Register<T = HexString> = {\n  R4: T;\n} & NonMandatoryRegisters<T>;\n\nexport type R4ToR5Registers<T = HexString> = {\n  R4: T;\n  R5: T;\n} & NonMandatoryRegisters<T>;\n\nexport type R4ToR6Registers<T = HexString> = {\n  R4: T;\n  R5: T;\n  R6: T;\n} & NonMandatoryRegisters<T>;\n\nexport type R4ToR7Registers<T = HexString> = {\n  R4: T;\n  R5: T;\n  R6: T;\n  R7: T;\n} & NonMandatoryRegisters<T>;\n\nexport type R4ToR8Registers<T = HexString> = {\n  R4: T;\n  R5: T;\n  R6: T;\n  R7: T;\n  R8: T;\n} & NonMandatoryRegisters<T>;\n\nexport type R4ToR9Registers<T = HexString> = {\n  R4: T;\n  R5: T;\n  R6: T;\n  R7: T;\n  R8: T;\n  R9: T;\n} & NonMandatoryRegisters<T>;\n\nexport type SequentialNonMandatoryRegisters<T extends AdditionalRegistersInput> =\n  T extends {\n    R9: ConstantInput;\n  }\n    ? R4ToR9Registers<ConstantInput>\n    : T extends { R8: ConstantInput }\n      ? R4ToR8Registers<ConstantInput>\n      : T extends { R7: ConstantInput }\n        ? R4ToR7Registers<ConstantInput>\n        : T extends { R6: ConstantInput }\n          ? R4ToR6Registers<ConstantInput>\n          : T extends { R5: ConstantInput }\n            ? R4ToR5Registers<ConstantInput>\n            : T extends { R4: ConstantInput }\n              ? OnlyR4Register<ConstantInput>\n              : T;\n","export class NonStandardizedMinting extends Error {}\n","import type {\n  Amount,\n  Box,\n  CollectionAddOptions,\n  OneOrMore,\n  TokenAmount\n} from \"@fleet-sdk/common\";\nimport { NotAllowedTokenBurning, type OutputBuilder, type TransactionBuilder } from \"..\";\n\nexport type FleetPluginContext = {\n  /**\n   * Add and ensures selection of one or more inputs to the inputs list\n   * @param inputs\n   * @returns new list length\n   */\n  addInputs: (inputs: OneOrMore<Box<Amount>>) => number;\n\n  /**\n   * Add one or more data inputs to the data inputs list\n   * @param dataInputs\n   * @returns new list length\n   */\n  addDataInputs: (\n    dataInputs: OneOrMore<Box<Amount>>,\n    options?: CollectionAddOptions\n  ) => number;\n\n  /**\n   * Add one or more outputs to the outputs list\n   * @param outputs\n   * @param options\n   * @returns new list length\n   */\n  addOutputs: (\n    outputs: OneOrMore<OutputBuilder>,\n    options?: CollectionAddOptions\n  ) => number;\n\n  /**\n   * Burn tokens\n   * @param tokens\n   * @throws Burning tokens thought a plugin, requires explicitly permission\n   * from {@link TransactionBuilder.configure}, if token burning is not allowed\n   * it will thrown a {@link NotAllowedTokenBurning} exception.\n   */\n  burnTokens: (tokens: OneOrMore<TokenAmount<Amount>>) => void;\n\n  /**\n   * Set transaction fee amount\n   * @param amount amount in nanoergs\n   */\n  setFee: (amount: Amount) => void;\n};\n\nexport function createPluginContext(\n  transactionBuilder: TransactionBuilder\n): FleetPluginContext {\n  return {\n    addInputs: (inputs) =>\n      transactionBuilder\n        .from(inputs)\n        .configureSelector((selector) =>\n          selector.ensureInclusion(\n            Array.isArray(inputs) ? inputs.map((input) => input.boxId) : inputs.boxId\n          )\n        ).inputs.length,\n    addOutputs: (outputs, options) =>\n      transactionBuilder.to(outputs, options).outputs.length,\n    addDataInputs: (dataInputs, options) =>\n      transactionBuilder.withDataFrom(dataInputs, options).dataInputs.length,\n    burnTokens: (tokens) => {\n      if (!transactionBuilder.settings.canBurnTokensFromPlugins) {\n        throw new NotAllowedTokenBurning();\n      }\n      transactionBuilder.burnTokens(tokens);\n    },\n    setFee: (amount) => transactionBuilder.payFee(amount)\n  };\n}\n","import { MAX_TOKENS_PER_BOX } from \"../models\";\n\nexport class TransactionBuilderSettings {\n  private _maxDistinctTokensPerChangeBox: number;\n  private _allowTokenBurning: boolean;\n  private _allowTokenBurningFromPlugins: boolean;\n  private _isolateErgOnChange: boolean;\n\n  constructor() {\n    this._maxDistinctTokensPerChangeBox = MAX_TOKENS_PER_BOX;\n    this._allowTokenBurning = false;\n    this._allowTokenBurningFromPlugins = false;\n    this._isolateErgOnChange = false;\n  }\n\n  public get maxTokensPerChangeBox(): number {\n    return this._maxDistinctTokensPerChangeBox;\n  }\n\n  public get canBurnTokens(): boolean {\n    return this._allowTokenBurning;\n  }\n\n  public get canBurnTokensFromPlugins(): boolean {\n    return this.canBurnTokens || this._allowTokenBurningFromPlugins;\n  }\n\n  public get shouldIsolateErgOnChange(): boolean {\n    return this._isolateErgOnChange;\n  }\n\n  /**\n   * Define max number of distinct tokens per change box\n   */\n  public setMaxTokensPerChangeBox(max: number): TransactionBuilderSettings {\n    this._maxDistinctTokensPerChangeBox = max;\n\n    return this;\n  }\n\n  /**\n   * Allows or denies token burning from all contexts\n   */\n  public allowTokenBurning(allow = true): TransactionBuilderSettings {\n    this._allowTokenBurning = allow;\n\n    return this;\n  }\n\n  /**\n   * Allows or denies token burning **only** from plugins context.\n   */\n  public allowTokenBurningFromPlugins(allow = true): TransactionBuilderSettings {\n    this._allowTokenBurningFromPlugins = allow;\n\n    return this;\n  }\n\n  /**\n   * If true, it creates an exclusive change box only for ERG.\n   * This setting is especially useful for Ledger devices to\n   * help on avoiding to hit the max tokens limit per transaction.\n   */\n  public isolateErgOnChange(isolate = true): TransactionBuilderSettings {\n    this._isolateErgOnChange = isolate;\n\n    return this;\n  }\n}\n","import {\n  _0n,\n  type Amount,\n  type Base58String,\n  type Box,\n  byteSizeOf,\n  chunk,\n  type CollectionAddOptions,\n  ensureBigInt,\n  first,\n  type HexString,\n  isDefined,\n  isHex,\n  isUndefined,\n  Network,\n  type OneOrMore,\n  some,\n  type TokenAmount,\n  utxoDiff,\n  utxoSum\n} from \"@fleet-sdk/common\";\nimport { estimateVLQSize } from \"@fleet-sdk/serializer\";\nimport { InvalidInput, MalformedTransaction, NotAllowedTokenBurning } from \"../errors\";\nimport { NonStandardizedMinting } from \"../errors/nonStandardizedMinting\";\nimport {\n  ErgoAddress,\n  InputsCollection,\n  OutputsCollection,\n  TokensCollection\n} from \"../models\";\nimport { ErgoUnsignedTransaction } from \"../models/ergoUnsignedTransaction\";\nimport {\n  BOX_VALUE_PER_BYTE,\n  estimateMinBoxValue,\n  OutputBuilder,\n  SAFE_MIN_BOX_VALUE\n} from \"./outputBuilder\";\nimport { createPluginContext, type FleetPluginContext } from \"./pluginContext\";\nimport { BoxSelector } from \"./selector\";\nimport { TransactionBuilderSettings } from \"./transactionBuilderSettings\";\n\ntype PluginListItem = { execute: FleetPlugin; pending: boolean };\ntype SelectorSettings = Omit<BoxSelector<Box<bigint>>, \"select\">;\nexport type ConfigureCallback = (settings: TransactionBuilderSettings) => void;\nexport type SelectorCallback = (selector: SelectorSettings) => void;\nexport type FleetPlugin = (context: FleetPluginContext) => void;\nexport type CollectionLike<T> = { toArray(): T[] };\n\nexport const RECOMMENDED_MIN_FEE_VALUE = BigInt(1100000);\nexport const FEE_CONTRACT =\n  \"1005040004000e36100204a00b08cd0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ea02d192a39a8cc7a701730073011001020402d19683030193a38cc7b2a57300000193c2b2a57301007473027303830108cdeeac93b1a57304\";\n\ntype EjectorContext = {\n  inputs: InputsCollection;\n  dataInputs: InputsCollection;\n  outputs: OutputsCollection;\n  burning: TokensCollection | undefined;\n  settings: TransactionBuilderSettings;\n  selection: (selectorCallBack: SelectorCallback) => void;\n};\n\nexport class TransactionBuilder {\n  private readonly _inputs!: InputsCollection;\n  private readonly _dataInputs!: InputsCollection;\n  private readonly _outputs!: OutputsCollection;\n  private readonly _settings!: TransactionBuilderSettings;\n  private readonly _creationHeight!: number;\n\n  private _selectorCallbacks?: SelectorCallback[];\n  private _changeAddress?: ErgoAddress;\n  private _feeAmount?: bigint;\n  private _burning?: TokensCollection;\n  private _plugins?: PluginListItem[];\n\n  constructor(creationHeight: number) {\n    this._inputs = new InputsCollection();\n    this._dataInputs = new InputsCollection();\n    this._outputs = new OutputsCollection();\n    this._settings = new TransactionBuilderSettings();\n    this._creationHeight = creationHeight;\n  }\n\n  public get inputs(): InputsCollection {\n    return this._inputs;\n  }\n\n  public get dataInputs(): InputsCollection {\n    return this._dataInputs;\n  }\n\n  public get outputs(): OutputsCollection {\n    return this._outputs;\n  }\n\n  public get changeAddress(): ErgoAddress | undefined {\n    return this._changeAddress;\n  }\n\n  public get fee(): bigint | undefined {\n    return this._feeAmount;\n  }\n\n  public get burning(): TokensCollection | undefined {\n    return this._burning;\n  }\n\n  public get settings(): TransactionBuilderSettings {\n    return this._settings;\n  }\n\n  public get creationHeight(): number {\n    return this._creationHeight;\n  }\n\n  /**\n   * Syntax sugar to be used in composition with another methods\n   *\n   * @example\n   * ```\n   * new TransactionBuilder(height)\n   *   .from(inputs)\n   *   .and.from(otherInputs);\n   * ```\n   */\n  public get and(): TransactionBuilder {\n    return this;\n  }\n\n  public from(\n    inputs: OneOrMore<Box<Amount>> | CollectionLike<Box<Amount>>\n  ): TransactionBuilder {\n    this._inputs.add(isCollectionLike(inputs) ? inputs.toArray() : inputs);\n    return this;\n  }\n\n  public to(\n    outputs: OneOrMore<OutputBuilder>,\n    options?: CollectionAddOptions\n  ): TransactionBuilder {\n    this._outputs.add(outputs, options);\n\n    return this;\n  }\n\n  public withDataFrom(\n    dataInputs: OneOrMore<Box<Amount>>,\n    options?: CollectionAddOptions\n  ): TransactionBuilder {\n    this._dataInputs.add(dataInputs, options);\n\n    return this;\n  }\n\n  public sendChangeTo(\n    address: ErgoAddress | Base58String | HexString\n  ): TransactionBuilder {\n    if (typeof address === \"string\") {\n      this._changeAddress = isHex(address)\n        ? ErgoAddress.fromErgoTree(address, Network.Mainnet)\n        : ErgoAddress.fromBase58(address);\n    } else {\n      this._changeAddress = address;\n    }\n\n    return this;\n  }\n\n  public payFee(amount: Amount): TransactionBuilder {\n    this._feeAmount = ensureBigInt(amount);\n\n    return this;\n  }\n\n  public payMinFee(): TransactionBuilder {\n    this.payFee(RECOMMENDED_MIN_FEE_VALUE);\n\n    return this;\n  }\n\n  public burnTokens(tokens: OneOrMore<TokenAmount<Amount>>): TransactionBuilder {\n    if (!this._burning) {\n      this._burning = new TokensCollection();\n    }\n    this._burning.add(tokens);\n\n    return this;\n  }\n\n  public configure(callback: ConfigureCallback): TransactionBuilder {\n    callback(this._settings);\n\n    return this;\n  }\n\n  public configureSelector(selectorCallback: SelectorCallback): TransactionBuilder {\n    if (isUndefined(this._selectorCallbacks)) {\n      this._selectorCallbacks = [];\n    }\n\n    this._selectorCallbacks.push(selectorCallback);\n\n    return this;\n  }\n\n  public extend(plugins: FleetPlugin): TransactionBuilder {\n    if (!this._plugins) {\n      this._plugins = [];\n    }\n    this._plugins.push({ execute: plugins, pending: true });\n\n    return this;\n  }\n\n  public eject(ejector: (context: EjectorContext) => void): TransactionBuilder {\n    ejector({\n      inputs: this.inputs,\n      dataInputs: this.dataInputs,\n      outputs: this.outputs,\n      burning: this.burning,\n      settings: this.settings,\n      selection: (selectorCallback: SelectorCallback) => {\n        this.configureSelector(selectorCallback);\n      }\n    });\n\n    return this;\n  }\n\n  public build(): ErgoUnsignedTransaction {\n    if (some(this._plugins)) {\n      const context = createPluginContext(this);\n      for (const plugin of this._plugins) {\n        if (plugin.pending) {\n          plugin.execute(context);\n          plugin.pending = false;\n        }\n      }\n    }\n\n    if (this._isMinting()) {\n      if (this._isMoreThanOneTokenBeingMinted()) {\n        throw new MalformedTransaction(\"only one token can be minted per transaction.\");\n      }\n\n      if (this._isTheSameTokenBeingMintedFromOutsideTheMintingBox()) {\n        throw new NonStandardizedMinting(\n          \"EIP-4 tokens cannot be minted from outside of the minting box.\"\n        );\n      }\n    }\n\n    this.outputs\n      .toArray()\n      .map((output) =>\n        output.setCreationHeight(this._creationHeight, { replace: false })\n      );\n    const outputs = this.outputs.clone();\n\n    if (isDefined(this._feeAmount)) {\n      outputs.add(new OutputBuilder(this._feeAmount, FEE_CONTRACT));\n    }\n\n    const selector = new BoxSelector(this.inputs.toArray());\n    if (some(this._selectorCallbacks)) {\n      for (const selectorCallBack of this._selectorCallbacks) {\n        selectorCallBack(selector);\n      }\n    }\n\n    const target = some(this._burning)\n      ? outputs.sum({ tokens: this._burning.toArray() })\n      : outputs.sum();\n    let inputs = selector.select(target);\n\n    if (isDefined(this._changeAddress)) {\n      const firstInputId = inputs[0].boxId;\n      const manualMintingTokenId = target.tokens.some((x) => x.tokenId === firstInputId)\n        ? firstInputId\n        : undefined;\n\n      if (manualMintingTokenId) {\n        target.tokens = target.tokens.filter((x) => x.tokenId !== manualMintingTokenId);\n      }\n\n      let change = utxoDiff(utxoSum(inputs), target);\n      const changeBoxes: OutputBuilder[] = [];\n\n      if (some(change.tokens)) {\n        let minRequiredNanoErgs = estimateMinChangeValue({\n          changeAddress: this._changeAddress,\n          creationHeight: this._creationHeight,\n          tokens: change.tokens,\n          maxTokensPerBox: this.settings.maxTokensPerChangeBox,\n          baseIndex: this.outputs.length + 1\n        });\n\n        while (minRequiredNanoErgs > change.nanoErgs) {\n          inputs = selector.select({\n            nanoErgs: target.nanoErgs + minRequiredNanoErgs,\n            tokens: target.tokens\n          });\n\n          change = utxoDiff(utxoSum(inputs), target);\n          minRequiredNanoErgs = estimateMinChangeValue({\n            changeAddress: this._changeAddress,\n            creationHeight: this._creationHeight,\n            tokens: change.tokens,\n            maxTokensPerBox: this.settings.maxTokensPerChangeBox,\n            baseIndex: this.outputs.length + 1\n          });\n        }\n\n        const chunkedTokens = chunk(change.tokens, this._settings.maxTokensPerChangeBox);\n        for (const tokens of chunkedTokens) {\n          const output = new OutputBuilder(\n            estimateMinBoxValue(),\n            this._changeAddress,\n            this._creationHeight\n          ).addTokens(tokens);\n\n          change.nanoErgs -= output.value;\n          changeBoxes.push(output);\n        }\n      }\n\n      if (change.nanoErgs > _0n) {\n        if (some(changeBoxes)) {\n          if (this.settings.shouldIsolateErgOnChange) {\n            outputs.add(new OutputBuilder(change.nanoErgs, this._changeAddress));\n          } else {\n            const firstChangeBox = first(changeBoxes);\n            firstChangeBox.setValue(firstChangeBox.value + change.nanoErgs);\n          }\n\n          outputs.add(changeBoxes);\n        } else {\n          outputs.add(new OutputBuilder(change.nanoErgs, this._changeAddress));\n        }\n      }\n    }\n\n    for (const input of inputs) {\n      if (!input.isValid()) throw new InvalidInput(input.boxId);\n    }\n\n    const unsignedTransaction = new ErgoUnsignedTransaction(\n      inputs,\n      this.dataInputs.toArray(),\n      outputs\n        .toArray()\n        .map((output) =>\n          output.setCreationHeight(this._creationHeight, { replace: false }).build(inputs)\n        )\n    );\n\n    let burning = unsignedTransaction.burning;\n    if (burning.nanoErgs > _0n) {\n      throw new MalformedTransaction(\"it's not possible to burn ERG.\");\n    }\n\n    if (some(burning.tokens) && some(this._burning)) {\n      burning = utxoDiff(burning, { nanoErgs: _0n, tokens: this._burning.toArray() });\n    }\n\n    if (!this._settings.canBurnTokens && some(burning.tokens)) {\n      throw new NotAllowedTokenBurning();\n    }\n\n    return unsignedTransaction;\n  }\n\n  private _getMintingOutput(): OutputBuilder | undefined {\n    for (const output of this._outputs) {\n      if (output.minting) return output;\n    }\n\n    return;\n  }\n\n  private _isMinting(): boolean {\n    return this._getMintingOutput() !== undefined;\n  }\n\n  private _getMintingTokenId(): string | undefined {\n    return this._getMintingOutput()?.minting?.tokenId;\n  }\n\n  private _isMoreThanOneTokenBeingMinted(): boolean {\n    let mintingCount = 0;\n\n    for (const output of this._outputs) {\n      if (output.minting) {\n        mintingCount++;\n        if (mintingCount > 1) return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _isTheSameTokenBeingMintedFromOutsideTheMintingBox(): boolean {\n    const mintingTokenId = this._getMintingTokenId();\n    if (isUndefined(mintingTokenId)) return false;\n\n    let count = 0;\n    for (const output of this._outputs) {\n      if (output.assets.contains(mintingTokenId)) {\n        count++;\n        if (count > 1) return true;\n      }\n    }\n\n    return false;\n  }\n}\n\nfunction isCollectionLike<T>(obj: unknown): obj is CollectionLike<T> {\n  return (obj as CollectionLike<T>).toArray !== undefined;\n}\n\ntype ChangeEstimationParams = {\n  changeAddress: ErgoAddress;\n  creationHeight: number;\n  tokens: TokenAmount<bigint>[];\n  baseIndex: number;\n  maxTokensPerBox: number;\n};\n\nfunction estimateMinChangeValue(params: ChangeEstimationParams): bigint {\n  const size = BigInt(estimateChangeSize(params));\n\n  return size * BOX_VALUE_PER_BYTE;\n}\n\nfunction estimateChangeSize({\n  changeAddress,\n  creationHeight,\n  tokens,\n  baseIndex,\n  maxTokensPerBox\n}: ChangeEstimationParams): number {\n  const neededBoxes = Math.ceil(tokens.length / maxTokensPerBox);\n  let size = 0;\n  size += estimateVLQSize(SAFE_MIN_BOX_VALUE);\n  size += byteSizeOf(changeAddress.ergoTree);\n  size += estimateVLQSize(creationHeight);\n  size += estimateVLQSize(0); // empty registers length\n  size += 32; // BLAKE 256 hash length\n\n  size = size * neededBoxes;\n  for (let i = 0; i < neededBoxes; i++) {\n    size += estimateVLQSize(baseIndex + i);\n  }\n\n  for (const token of tokens) {\n    size += byteSizeOf(token.tokenId) + estimateVLQSize(token.amount);\n  }\n\n  if (tokens.length > maxTokensPerBox) {\n    if (tokens.length % maxTokensPerBox > 0) {\n      size +=\n        estimateVLQSize(maxTokensPerBox) * Math.floor(tokens.length / maxTokensPerBox);\n      size += estimateVLQSize(tokens.length % maxTokensPerBox);\n    } else {\n      size += estimateVLQSize(maxTokensPerBox) * neededBoxes;\n    }\n  } else {\n    size += estimateVLQSize(tokens.length);\n  }\n\n  return size;\n}\n","import type { HexString } from \"@fleet-sdk/common\";\nimport {\n  SBigInt,\n  SBool,\n  SByte,\n  SColl,\n  SCollType,\n  SConstant as SerSConstant,\n  SGroupElement,\n  SInt,\n  SLong,\n  SShort,\n  SSigmaProp,\n  SType,\n  SUnit\n} from \"@fleet-sdk/serializer\";\n\n/**\n * @deprecated Use {@link @fleet-sdk/serializer} instead.\n * This function will be removed from core package in v1.0.0.\n */\nexport function SConstant(constant: SerSConstant): HexString {\n  return constant.toHex();\n}\n\n/**\n * @deprecated Use {@link @fleet-sdk/serializer} instead.\n * This function will be removed from core package in v1.0.0.\n */\nexport function SParse<T>(bytes: HexString | Uint8Array): T {\n  return SerSConstant.from<T>(bytes).data;\n}\n\nexport {\n  SBigInt,\n  SBool,\n  SByte,\n  SCollType,\n  SColl,\n  SGroupElement,\n  SInt,\n  SLong,\n  SShort,\n  SSigmaProp,\n  SType,\n  SUnit\n};\n"]}