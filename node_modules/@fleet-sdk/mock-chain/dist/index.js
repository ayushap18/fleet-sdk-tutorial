'use strict';

var common = require('@fleet-sdk/common');
var crypto = require('@fleet-sdk/crypto');
var main = require('sigmastate-js/main');
var core = require('@fleet-sdk/core');
var serializer = require('@fleet-sdk/serializer');
var pc = require('picocolors');
var diff = require('diff');
var wallet = require('@fleet-sdk/wallet');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var pc__default = /*#__PURE__*/_interopDefault(pc);

// src/execution.ts
function mockUTxO(mock) {
  const box = {
    boxId: "",
    value: mock.value ?? core.SAFE_MIN_BOX_VALUE,
    ergoTree: mock.ergoTree,
    assets: mock.assets ?? [],
    creationHeight: mock.creationHeight ?? 0,
    additionalRegisters: mock.additionalRegisters ?? {},
    transactionId: mock.transactionId ?? getRandomId(),
    index: mock.index ?? 0
  };
  const bytes = serializer.serializeBox(box).toBytes();
  box.boxId = crypto.hex.encode(crypto.blake2b256(bytes));
  return box;
}
function getRandomId() {
  return crypto.hex.encode(crypto.randomBytes(32));
}
var BLOCK_TIME = 2;
function mockHeaders(count, options) {
  const headers = new Array(count);
  const height = (options?.fromHeight ?? 0) + count;
  const timestamp = options?.fromTimestamp ? new Date(options.fromTimestamp) : /* @__PURE__ */ new Date();
  const version = options?.version ?? 3;
  let parentId = options?.parentId || getRandomId();
  for (let i = 0; i < count; i++) {
    const id = getRandomId();
    if (i > 0) timestamp.setMinutes(timestamp.getMinutes() - BLOCK_TIME);
    headers[i] = {
      id,
      parentId,
      version,
      height: height - i,
      adProofsRoot: "094a38dca68383996db603b11d7a4a2c2ca2cfd45946208c89fdcf73fa4bed2f",
      stateRoot: "6c64d4ffdf34b31b81c8fbb7cebb78ce12f5c7e5c61864c6523bf1481c8011c619",
      transactionsRoot: "0c9778e550d39b8423a2247a73a05169369054ef6edaf30f2842b223ed3cc450",
      timestamp: timestamp.getTime(),
      nBits: 118081018,
      extensionHash: "33c61204c775128d6d19754d9be6b4c7ab06a2af7d8f95e6662df476a394be51",
      powSolutions: {
        pk: "0295facb78290ac2b55f1453204d49df37be5bae9f185ed6704c1ba3ee372280c1",
        w: "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        n: "712b000abb1f4e33",
        d: "0"
      },
      votes: "000000"
    };
    parentId = id;
  }
  return headers.reverse();
}
function mockBlockchainStateContext(options) {
  const headers = mockHeaders(
    (options?.headers?.quantity ?? 10) + 1,
    options?.headers
  ).map((h) => ({
    ...h,
    ADProofsRoot: h.adProofsRoot,
    stateRoot: main.AvlTree$.fromDigest(h.stateRoot),
    timestamp: BigInt(h.timestamp),
    nBits: BigInt(h.nBits),
    extensionRoot: h.extensionHash,
    minerPk: main.GroupElement$.fromPointHex(h.powSolutions.pk),
    powOnetimePk: main.GroupElement$.fromPointHex(h.powSolutions.w),
    powNonce: h.powSolutions.n,
    powDistance: BigInt(h.powSolutions.d)
  }));
  return {
    sigmaLastHeaders: headers.slice(1),
    previousStateDigest: headers[1].stateRoot.digest,
    sigmaPreHeader: headers[0]
  };
}

// src/execution.ts
var BLOCKCHAIN_PARAMETERS = {
  storageFeeFactor: 125e4,
  minValuePerByte: 360,
  maxBlockSize: 1271009,
  tokenAccessCost: 100,
  inputCost: 2407,
  dataInputCost: 100,
  outputCost: 197,
  maxBlockCost: 8001091,
  blockVersion: 3
};
function execute(unsigned, keys, parameters) {
  for (const key of keys) {
    if (!key.hasPrivateKey()) {
      throw new Error(
        `ErgoHDKey '${crypto.hex.encode(key.publicKey)}' must have a private key.`
      );
    }
  }
  const eip12Tx = unsigned.toEIP12Object();
  const params = common.ensureDefaults(parameters, {
    context: mockBlockchainStateContext(),
    parameters: BLOCKCHAIN_PARAMETERS,
    network: common.Network.Mainnet,
    baseCost: 0
  });
  try {
    const builder = main.ProverBuilder$.create(params.parameters, params.network);
    for (const key of keys) {
      builder.withDLogSecret(crypto.bigintBE.encode(key.privateKey));
    }
    const prover = builder.build();
    const reducedTx = prover.reduce(
      params.context,
      eip12Tx,
      eip12Tx.inputs,
      eip12Tx.dataInputs,
      unsigned.burning.tokens,
      params.baseCost
    );
    prover.signReduced(reducedTx);
    return { success: true };
  } catch (e) {
    return { success: false, reason: e.message };
  }
}
var ELLIPSIS = "...";
function stringifyBalance(balance, name, width, metadata) {
  const tokenWidth = width * 70 / 100;
  const rows = [
    line("-", width),
    center(compact(`- ${name} -`, width - 4), width),
    line("-", width),
    between("Asset", "Balance", width),
    line("=", width),
    between(
      metaName("nanoerg", metadata),
      metaAmount("nanoerg", balance.nanoergs, metadata),
      width
    )
  ];
  if (common.some(balance.tokens)) {
    for (const token of balance.tokens) {
      rows.push(
        between(
          metaName(token.tokenId, metadata),
          metaAmount(token.tokenId, token.amount, metadata),
          width,
          tokenWidth
        )
      );
    }
  }
  rows.push(line("-", width));
  return rows.join("\n");
}
function metaName(key, metadata) {
  return metadata?.get(key)?.name || key;
}
function metaAmount(key, amount, metadata) {
  const decimals = metadata?.get(key)?.decimals;
  if (decimals) {
    return common.decimalize(amount, decimals);
  }
  return amount.toString();
}
function between(leftStr, rightStr, length, maxLeftLength) {
  const rlen = length - rightStr.length - 1;
  const r = compact(
    leftStr,
    maxLeftLength && maxLeftLength <= rlen ? maxLeftLength : rlen
  );
  const l = right(rightStr, length - r.length);
  return r + l;
}
function printDiff(oldVal, newVal) {
  const diff$1 = diff.diffArrays(oldVal.split("\n"), newVal.split("\n"));
  diff$1.map((part) => part.value.map((row) => log(row, part)));
}
function log(value, part) {
  const colored = part.added ? pc__default.default.green(`+ ${value}`) : part.removed ? pc__default.default.red(`- ${value}`) : pc__default.default.gray(`  ${value}`);
  console.log(colored);
}
function line(char, length) {
  return maxLength(char.repeat(length), length);
}
function maxLength(str, length) {
  if (str.length < length) {
    return str;
  }
  return str.slice(0, length);
}
function right(str, length) {
  return str.padStart(length);
}
function center(str, length) {
  if (str.length > length) {
    return str;
  }
  const half = (length + str.length) / 2;
  return str.padStart(half).padEnd(length);
}
function compact(val, length) {
  if (length >= val.length) return val;
  if (length <= 0) return "";
  if (length <= ELLIPSIS.length + 2) return maxLength(val, length);
  const fragmentSize = Math.trunc((length - ELLIPSIS.length) / 2);
  return maxLength(
    `${val.slice(0, fragmentSize).trimEnd()}${ELLIPSIS}${val.slice(val.length - fragmentSize).trimStart()}`,
    length
  );
}
function isUTxOCandidate(candidate) {
  return common.isUndefined(candidate.boxId);
}
var MockUTxOCollection = class extends common.Collection {
  constructor(boxes) {
    super();
    if (common.isDefined(boxes)) {
      this.add(boxes);
    }
  }
  _map(utxo) {
    if (isUTxOCandidate(utxo)) {
      return mockUTxO(common.ensureUTxOBigInt(utxo));
    }
    return common.ensureUTxOBigInt(utxo);
  }
  _addOne(utxo) {
    if (this._items.some((item) => item.boxId === utxo.boxId)) {
      throw new core.DuplicateInputError(utxo.boxId);
    }
    return super._addOne(utxo);
  }
  clear() {
    this._items.length = 0;
  }
  remove(boxIdOrIndex) {
    let index = -1;
    if (typeof boxIdOrIndex === "number") {
      if (this._isIndexOutOfBounds(boxIdOrIndex)) {
        throw new RangeError(`Index '${boxIdOrIndex}' is out of range.`);
      }
      index = boxIdOrIndex;
    } else {
      index = this._items.findIndex((box) => box.boxId === boxIdOrIndex);
      if (this._isIndexOutOfBounds(index)) {
        throw new core.NotFoundError(
          "The UTxO you are trying to remove is not present in the UTxOs collection."
        );
      }
    }
    this._items.splice(index, 1);
    return this.length;
  }
  some(predicate) {
    return this._items.some(predicate);
  }
  exists(boxId) {
    return this._items.some((x) => x.boxId === boxId);
  }
};

// src/party/mockChainParty.ts
var MockChainParty = class {
  _name;
  _utxos;
  _address;
  _ergoTree;
  _chain;
  constructor(chain, address, name) {
    this._chain = chain;
    this._address = address;
    this._name = name;
    this._ergoTree = this._address.ergoTree;
    this._utxos = new MockUTxOCollection();
  }
  get address() {
    return this._address;
  }
  get name() {
    return this._name || this._address.encode();
  }
  get utxos() {
    return this._utxos;
  }
  get ergoTree() {
    return this._ergoTree;
  }
  get chain() {
    return this._chain;
  }
  get balance() {
    const summary = common.utxoSum(this._utxos.toArray());
    return { nanoergs: summary.nanoErgs, tokens: summary.tokens };
  }
  addUTxOs(utxos) {
    this._utxos.add(utxos);
    return this;
  }
  /**
   * Syntax sugar for `addUTxOs`
   * @param utxos
   * @returns
   */
  withUTxOs(utxos) {
    return this.addUTxOs(utxos);
  }
  addBalance(balance, additionalRegisters) {
    this.addUTxOs({
      value: balance.nanoergs || core.SAFE_MIN_BOX_VALUE,
      assets: balance.tokens || [],
      ergoTree: this._ergoTree,
      creationHeight: this._chain.height,
      additionalRegisters: additionalRegisters || {}
    });
    return this;
  }
  /**
   * Syntax sugar for `addBalance`
   * @param utxos
   * @returns
   */
  withBalance(balance, additionalRegisters) {
    return this.addBalance(balance, additionalRegisters);
  }
  toString(width = 50) {
    return stringifyBalance(this.balance, this.name, width, this._chain.assetsMetadata);
  }
};
var KeyedMockChainParty = class extends MockChainParty {
  _key;
  constructor(chain, name) {
    const seed = crypto.randomBytes(32);
    const key = wallet.ErgoHDKey.fromMasterSeed(seed);
    super(chain, key.address, name);
    this._key = key;
  }
  get key() {
    return this._key;
  }
};
var NonKeyedMockChainParty = class extends MockChainParty {
  constructor(chain, ergoTree, name) {
    common.assert(
      typeof ergoTree === "string",
      "A non-keyed party needs a valid ErgoTree to be instantiated."
    );
    const address = core.ErgoAddress.fromErgoTree(ergoTree);
    super(chain, address, name);
  }
};

// src/mockChain.ts
var BLOCK_TIME_MS = 12e4;
var MockChain = class {
  #parties;
  #tip;
  #base;
  #metadataMap;
  constructor(heightOrOptions) {
    const options = !heightOrOptions || typeof heightOrOptions === "number" ? { height: heightOrOptions ?? 0 } : heightOrOptions;
    const state = common.ensureDefaults(options, {
      height: 0,
      timestamp: (/* @__PURE__ */ new Date()).getTime(),
      parameters: common.ensureDefaults(options.parameters, BLOCKCHAIN_PARAMETERS)
    });
    this.#tip = state;
    this.#base = { ...state };
    this.#parties = [];
    this.#metadataMap = /* @__PURE__ */ new Map();
  }
  get assetsMetadata() {
    return this.#metadataMap;
  }
  get height() {
    return this.#tip.height;
  }
  get timestamp() {
    return this.#tip.timestamp;
  }
  get parties() {
    return this.#parties;
  }
  newBlock() {
    this.newBlocks(1);
  }
  newBlocks(count) {
    this.#tip.height += count;
    this.#tip.timestamp += BLOCK_TIME_MS * count;
  }
  jumpTo(newHeight) {
    this.newBlocks(newHeight - this.#tip.height);
  }
  clearUTxOSet() {
    for (const party of this.#parties) {
      party.utxos.clear();
    }
  }
  reset() {
    this.clearUTxOSet();
    this.#tip.height = this.#base.height;
    this.#tip.timestamp = this.#base.timestamp;
  }
  newParty(optOrName) {
    return this.#pushParty(
      typeof optOrName === "string" || common.isUndefined(optOrName) ? new KeyedMockChainParty(this, optOrName) : new NonKeyedMockChainParty(this, optOrName.ergoTree, optOrName.name)
    );
  }
  addParty(ergoTree, name) {
    return this.#pushParty(new NonKeyedMockChainParty(this, ergoTree, name));
  }
  #pushParty(party) {
    this.#parties.push(party);
    return party;
  }
  execute(unsignedTransaction, options, baseCost) {
    const keys = (options?.signers || this.#parties).filter((p) => p instanceof KeyedMockChainParty).map((p) => p.key);
    const context = mockBlockchainStateContext({
      headers: {
        quantity: 10,
        fromHeight: this.#tip.height,
        fromTimestamp: this.#tip.timestamp
      }
    });
    const result = execute(unsignedTransaction, keys, {
      context,
      baseCost,
      parameters: this.#tip.parameters
    });
    if (!result.success) {
      if (options?.log) {
        log2(pc__default.default.red(`${pc__default.default.bgRed(pc__default.default.bold(" Error "))} ${result.reason}`));
      }
      if (options?.throw !== false) throw new Error(result.reason);
      return false;
    }
    const preExecBalances = options?.log ? this.#parties.map((party) => party.toString()) : void 0;
    const { inputs, outputs } = unsignedTransaction.toPlainObject();
    for (const party of this.#parties) {
      for (let i = inputs.length - 1; i >= 0; i--) {
        if (party.utxos.exists(inputs[i].boxId)) {
          party.utxos.remove(inputs[i].boxId);
        }
      }
      for (let i = outputs.length - 1; i >= 0; i--) {
        if (party.ergoTree === outputs[i].ergoTree) {
          party.utxos.add(outputs[i]);
          outputs.splice(i, 1);
        }
      }
    }
    this.#pushMetadata(unsignedTransaction);
    this.newBlock();
    if (common.some(preExecBalances) && result.success) {
      const postExecBalances = this.#parties.map((party) => party.toString());
      log2("State changes:\n");
      for (let i = 0; i < preExecBalances.length; i++) {
        printDiff(preExecBalances[i], postExecBalances[i]);
        log2("\n");
      }
    }
    return true;
  }
  #pushMetadata(transaction) {
    const firstInputId = common.first(transaction.inputs).boxId;
    const box = transaction.outputs.find(
      (output) => output.assets.some((asset) => asset.tokenId === firstInputId)
    );
    if (!box) return;
    const name = serializer.decode(box.additionalRegisters.R4, safeUtf8Encode);
    const decimals = serializer.decode(box.additionalRegisters.R6, safeUtf8Encode);
    if (name) {
      this.#metadataMap.set(firstInputId, {
        name,
        decimals: decimals ? Number.parseInt(decimals) : void 0
      });
    }
  }
};
function log2(str) {
  console.log(str);
}
var safeUtf8Encode = (v) => v instanceof Uint8Array ? crypto.utf8.encode(v) : void 0;

exports.BLOCKCHAIN_PARAMETERS = BLOCKCHAIN_PARAMETERS;
exports.KeyedMockChainParty = KeyedMockChainParty;
exports.MockChain = MockChain;
exports.MockChainParty = MockChainParty;
exports.NonKeyedMockChainParty = NonKeyedMockChainParty;
exports.execute = execute;
exports.mockBlockchainStateContext = mockBlockchainStateContext;
exports.mockHeaders = mockHeaders;
exports.mockUTxO = mockUTxO;
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map