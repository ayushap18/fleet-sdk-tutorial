import { Network, Collection, Box, Amount, BoxCandidate, BoxId, OneOrMore, TokenAmount, NonMandatoryRegisters, HexString } from '@fleet-sdk/common';
import { ErgoUnsignedTransaction, Box as Box$1, ErgoAddress } from '@fleet-sdk/core';
import { ErgoHDKey } from '@fleet-sdk/wallet';
import { BlockchainParameters, BlockchainStateContext } from 'sigmastate-js/main';

/**
 * blockchain parameters at height 1283632
 */
declare const BLOCKCHAIN_PARAMETERS: BlockchainParameters;
type TransactionExecutionResult = {
    success: boolean;
    reason?: string;
};
type ExecutionParameters = {
    context?: BlockchainStateContext;
    parameters?: BlockchainParameters;
    network?: Network;
    baseCost?: number;
};
declare function execute(unsigned: ErgoUnsignedTransaction, keys: ErgoHDKey[], parameters?: ExecutionParameters): TransactionExecutionResult;

declare class MockUTxOCollection extends Collection<Box<bigint>, MockUTxOInput> {
    constructor();
    constructor(box: Box<Amount>);
    constructor(boxes: Box<Amount>[]);
    protected _map(utxo: BoxCandidate<Amount> | Box<Amount>): Box<bigint>;
    protected _addOne(utxo: Box<Amount>): number;
    clear(): void;
    remove(boxId: BoxId): number;
    remove(index: number): number;
    some(predicate: (item: Box<bigint>) => unknown): boolean;
    exists(boxId: string): boolean;
}

type MockUTxOInput = OneOrMore<BoxCandidate<Amount>> | OneOrMore<Box$1<Amount>>;
type AddBalance = {
    nanoergs?: Amount;
    tokens?: TokenAmount<Amount>[];
};
type PartyBalance = {
    nanoergs: bigint;
    tokens: TokenAmount<bigint>[];
};
declare abstract class MockChainParty {
    private readonly _name?;
    private readonly _utxos;
    private readonly _address;
    private readonly _ergoTree;
    private readonly _chain;
    constructor(chain: MockChain, address: ErgoAddress, name?: string);
    get address(): ErgoAddress;
    get name(): string;
    get utxos(): MockUTxOCollection;
    get ergoTree(): string;
    get chain(): MockChain;
    get balance(): PartyBalance;
    addUTxOs(utxos: MockUTxOInput): MockChainParty;
    /**
     * Syntax sugar for `addUTxOs`
     * @param utxos
     * @returns
     */
    withUTxOs(utxos: MockUTxOInput): MockChainParty;
    addBalance(balance: AddBalance, additionalRegisters?: NonMandatoryRegisters): MockChainParty;
    /**
     * Syntax sugar for `addBalance`
     * @param utxos
     * @returns
     */
    withBalance(balance: AddBalance, additionalRegisters?: NonMandatoryRegisters): MockChainParty;
    toString(width?: number): string;
}

declare class KeyedMockChainParty extends MockChainParty {
    private readonly _key;
    constructor(chain: MockChain, name?: string);
    get key(): ErgoHDKey;
}

declare class NonKeyedMockChainParty extends MockChainParty {
    constructor(chain: MockChain, ergoTree: HexString, name?: string);
}

type AssetMetadata = {
    name?: string;
    decimals?: number;
};
type AssetMetadataMap = Map<"nanoerg" | (string & {}), AssetMetadata>;
type NonKeyedMockChainPartyOptions = {
    name?: string;
    ergoTree: string;
};
type TransactionExecutionOptions = {
    signers?: KeyedMockChainParty[];
    throw?: boolean;
    log?: boolean;
};
type MockChainOptions = {
    height?: number;
    timestamp?: number;
    parameters?: Partial<BlockchainParameters>;
};
type BlockState = {
    height: number;
    timestamp: number;
    parameters: BlockchainParameters;
};
declare class MockChain {
    #private;
    constructor();
    constructor(height?: number);
    constructor(options?: MockChainOptions);
    get assetsMetadata(): AssetMetadataMap;
    get height(): number;
    get timestamp(): number;
    get parties(): MockChainParty[];
    newBlock(): void;
    newBlocks(count: number): void;
    jumpTo(newHeight: number): void;
    clearUTxOSet(): void;
    reset(): void;
    newParty(name?: string): KeyedMockChainParty;
    newParty(nonKeyedOptions?: NonKeyedMockChainPartyOptions): NonKeyedMockChainParty;
    addParty(ergoTree: HexString, name?: string): NonKeyedMockChainParty;
    execute(unsignedTransaction: ErgoUnsignedTransaction, options?: TransactionExecutionOptions, baseCost?: number): boolean;
}

type MockBoxOptions = Partial<Omit<Box<bigint>, "boxId">> & {
    ergoTree: string;
};
declare function mockUTxO(mock: MockBoxOptions): Box<bigint>;
type HeaderMockingOptions = {
    parentId?: string;
    version?: number;
    fromHeight?: number;
    fromTimestamp?: number;
};
type BlockchainContextMockingOptions = {
    headers?: {
        quantity: number;
    } & HeaderMockingOptions;
};
type PoWSolutions = {
    pk: string;
    w: string;
    n: string;
    d: string;
};
type Header = {
    id: string;
    parentId: string;
    version: number;
    height: number;
    adProofsRoot: string;
    stateRoot: string;
    transactionsRoot: string;
    timestamp: number;
    nBits: number;
    extensionHash: string;
    powSolutions: PoWSolutions;
    votes: string;
};
declare function mockHeaders(count: number, options?: HeaderMockingOptions): Header[];
declare function mockBlockchainStateContext(options?: BlockchainContextMockingOptions): BlockchainStateContext;

export { type AddBalance, type AssetMetadata, type AssetMetadataMap, BLOCKCHAIN_PARAMETERS, type BlockState, type BlockchainContextMockingOptions, type ExecutionParameters, type Header, type HeaderMockingOptions, KeyedMockChainParty, MockChain, type MockChainOptions, MockChainParty, type MockUTxOInput, NonKeyedMockChainParty, type NonKeyedMockChainPartyOptions, type PartyBalance, type PoWSolutions, type TransactionExecutionOptions, type TransactionExecutionResult, execute, mockBlockchainStateContext, mockHeaders, mockUTxO };
