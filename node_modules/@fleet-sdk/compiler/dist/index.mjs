import { ensureDefaults, assert, ergoTreeHeaderFlags, isEmpty, isHex } from '@fleet-sdk/common';
import { SConstant } from '@fleet-sdk/serializer';
import { SigmaCompiler$, Value$, Value } from 'sigmastate-js/main';
import { ErgoTree } from '@fleet-sdk/core';
import { hex } from '@fleet-sdk/crypto';

// src/compiler.ts
var ContractTemplate = class {
  _bytes;
  constructor(bytes) {
    this._bytes = bytes;
  }
  toBytes() {
    return this._bytes;
  }
  toHex() {
    return hex.encode(this._bytes);
  }
};

// src/compilerOutput.ts
var CompilerOutput = class extends ErgoTree {
  _tree;
  _template;
  constructor(tree) {
    super(hex.decode(tree.toHex()));
    this._tree = tree;
  }
  get template() {
    if (!this._template) {
      const templateBytes = hex.decode(this._tree.templateHex());
      this._template = new ContractTemplate(templateBytes);
    }
    return this._template;
  }
  get constants() {
    return this._tree.constants();
  }
};

// src/compiler.ts
var compilerDefaults = {
  version: 1,
  map: {},
  segregateConstants: true
};
function compile(script, options) {
  const opt = ensureDefaults(options, compilerDefaults);
  assert(opt.version < 8, `Version should be lower than 8, got ${opt.version}`);
  let headerFlags = 0 | opt.version;
  if (opt.version > 0 || opt.version === 0 && opt.includeSize) {
    headerFlags |= ergoTreeHeaderFlags.sizeInclusion;
  }
  const tree = SigmaCompiler$.forMainnet().compile(
    parseNamedConstantsMap(opt.map),
    opt.segregateConstants,
    headerFlags,
    script
  );
  return new CompilerOutput(tree);
}
function parseNamedConstantsMap(map) {
  if (isEmpty(map)) {
    return map;
  }
  const sigmaMap = {};
  for (const key in map) {
    sigmaMap[key] = toSigmaConstant(map[key]);
  }
  return sigmaMap;
}
function toSigmaConstant(constant) {
  if (typeof constant === "string") {
    assert(isHex(constant), `'${constant}' is not a valid hex string.`);
    return Value$.fromHex(constant);
  }
  if (constant instanceof SConstant) return Value$.fromHex(constant.toHex());
  if (constant instanceof Value) return constant;
  throw new Error("Unsupported constant object mapping.");
}

export { CompilerOutput, ContractTemplate, compile };
//# sourceMappingURL=index.mjs.map
//# sourceMappingURL=index.mjs.map