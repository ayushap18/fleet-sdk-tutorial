'use strict';

var common = require('@fleet-sdk/common');
var serializer = require('@fleet-sdk/serializer');
var main = require('sigmastate-js/main');
var core = require('@fleet-sdk/core');
var crypto = require('@fleet-sdk/crypto');

// src/compiler.ts
var ContractTemplate = class {
  _bytes;
  constructor(bytes) {
    this._bytes = bytes;
  }
  toBytes() {
    return this._bytes;
  }
  toHex() {
    return crypto.hex.encode(this._bytes);
  }
};

// src/compilerOutput.ts
var CompilerOutput = class extends core.ErgoTree {
  _tree;
  _template;
  constructor(tree) {
    super(crypto.hex.decode(tree.toHex()));
    this._tree = tree;
  }
  get template() {
    if (!this._template) {
      const templateBytes = crypto.hex.decode(this._tree.templateHex());
      this._template = new ContractTemplate(templateBytes);
    }
    return this._template;
  }
  get constants() {
    return this._tree.constants();
  }
};

// src/compiler.ts
var compilerDefaults = {
  version: 1,
  map: {},
  segregateConstants: true
};
function compile(script, options) {
  const opt = common.ensureDefaults(options, compilerDefaults);
  common.assert(opt.version < 8, `Version should be lower than 8, got ${opt.version}`);
  let headerFlags = 0 | opt.version;
  if (opt.version > 0 || opt.version === 0 && opt.includeSize) {
    headerFlags |= common.ergoTreeHeaderFlags.sizeInclusion;
  }
  const tree = main.SigmaCompiler$.forMainnet().compile(
    parseNamedConstantsMap(opt.map),
    opt.segregateConstants,
    headerFlags,
    script
  );
  return new CompilerOutput(tree);
}
function parseNamedConstantsMap(map) {
  if (common.isEmpty(map)) {
    return map;
  }
  const sigmaMap = {};
  for (const key in map) {
    sigmaMap[key] = toSigmaConstant(map[key]);
  }
  return sigmaMap;
}
function toSigmaConstant(constant) {
  if (typeof constant === "string") {
    common.assert(common.isHex(constant), `'${constant}' is not a valid hex string.`);
    return main.Value$.fromHex(constant);
  }
  if (constant instanceof serializer.SConstant) return main.Value$.fromHex(constant.toHex());
  if (constant instanceof main.Value) return constant;
  throw new Error("Unsupported constant object mapping.");
}

exports.CompilerOutput = CompilerOutput;
exports.ContractTemplate = ContractTemplate;
exports.compile = compile;
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map