{"version":3,"sources":["../src/contractTemplate.ts","../src/compilerOutput.ts","../src/compiler.ts"],"names":["hex","ErgoTree","ensureDefaults","assert","ergoTreeHeaderFlags","SigmaCompiler$","isEmpty","isHex","Value$","SConstant","Value"],"mappings":"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","file":"index.js","sourcesContent":["import { hex } from \"@fleet-sdk/crypto\";\n\nexport class ContractTemplate {\n  private _bytes: Uint8Array;\n\n  constructor(bytes: Uint8Array) {\n    this._bytes = bytes;\n  }\n\n  toBytes() {\n    return this._bytes;\n  }\n\n  toHex() {\n    return hex.encode(this._bytes);\n  }\n}\n","import { ErgoTree } from \"@fleet-sdk/core\";\nimport { hex } from \"@fleet-sdk/crypto\";\nimport type { ErgoTree as SigmaErgoTree, Value as SigmaValue } from \"sigmastate-js/main\";\nimport { ContractTemplate } from \"./contractTemplate\";\n\nexport class CompilerOutput extends ErgoTree {\n  private readonly _tree: SigmaErgoTree;\n  private _template?: ContractTemplate;\n\n  constructor(tree: SigmaErgoTree) {\n    super(hex.decode(tree.toHex()));\n    this._tree = tree;\n  }\n\n  get template(): ContractTemplate {\n    if (!this._template) {\n      const templateBytes = hex.decode(this._tree.templateHex());\n      this._template = new ContractTemplate(templateBytes);\n    }\n\n    return this._template;\n  }\n\n  get constants(): SigmaValue[] {\n    return this._tree.constants();\n  }\n}\n","import {\n  assert,\n  ensureDefaults,\n  ergoTreeHeaderFlags,\n  isEmpty,\n  isHex\n} from \"@fleet-sdk/common\";\nimport { SConstant } from \"@fleet-sdk/serializer\";\nimport {\n  SigmaCompiler$,\n  type SigmaCompilerNamedConstantsMap,\n  Value,\n  Value$\n} from \"sigmastate-js/main\";\nimport { CompilerOutput } from \"./compilerOutput\";\n\ntype CompilerOptionsBase = {\n  version?: number;\n  map?: NamedConstantsMap;\n  segregateConstants?: boolean;\n};\n\nexport type CompilerOptionsForErgoTreeV0 = CompilerOptionsBase & {\n  version?: 0;\n  includeSize?: boolean;\n};\n\nexport type CompilerOptionsForErgoTreeV1 = CompilerOptionsBase & {\n  version?: 1;\n};\n\nexport type CompilerOptions = CompilerOptionsForErgoTreeV0 | CompilerOptionsForErgoTreeV1;\n\nexport type NamedConstantsMap = {\n  [key: string]: string | Value | SConstant;\n};\n\nexport const compilerDefaults: Required<CompilerOptions> = {\n  version: 1,\n  map: {},\n  segregateConstants: true\n};\n\nexport function compile(script: string, options?: CompilerOptions): CompilerOutput {\n  const opt = ensureDefaults(options, compilerDefaults);\n  assert(opt.version < 8, `Version should be lower than 8, got ${opt.version}`);\n\n  let headerFlags = 0x00 | opt.version;\n\n  if (opt.version > 0 || (opt.version === 0 && opt.includeSize)) {\n    headerFlags |= ergoTreeHeaderFlags.sizeInclusion;\n  }\n\n  const tree = SigmaCompiler$.forMainnet().compile(\n    parseNamedConstantsMap(opt.map),\n    opt.segregateConstants,\n    headerFlags,\n    script\n  );\n\n  return new CompilerOutput(tree);\n}\n\nexport function parseNamedConstantsMap(\n  map: NamedConstantsMap\n): SigmaCompilerNamedConstantsMap {\n  if (isEmpty(map)) {\n    return map;\n  }\n\n  const sigmaMap: SigmaCompilerNamedConstantsMap = {};\n  for (const key in map) {\n    sigmaMap[key] = toSigmaConstant(map[key]);\n  }\n\n  return sigmaMap;\n}\n\nexport function toSigmaConstant(constant: string | Value | SConstant): Value {\n  if (typeof constant === \"string\") {\n    assert(isHex(constant), `'${constant}' is not a valid hex string.`);\n    return Value$.fromHex(constant);\n  }\n  if (constant instanceof SConstant) return Value$.fromHex(constant.toHex());\n  if (constant instanceof Value) return constant;\n\n  throw new Error(\"Unsupported constant object mapping.\");\n}\n"]}