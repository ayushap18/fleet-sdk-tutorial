{"version":3,"sources":["../src/ergoHDKey.ts","../src/mnemonic.ts","../src/prover/proveDLogProtocol.ts","../src/prover/prover.ts"],"names":["wordlist","english","generate","validate","hex","blake2b256","isHex"],"mappings":"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","file":"index.mjs","sourcesContent":["import { isHex } from \"@fleet-sdk/common\";\nimport { ErgoAddress } from \"@fleet-sdk/core\";\nimport { base58check, hex } from \"@fleet-sdk/crypto\";\nimport { HDKey } from \"@scure/bip32\";\nimport { mnemonicToSeed, mnemonicToSeedSync } from \"@scure/bip39\";\n\n/**\n * Ergo derivation path at change level\n */\nexport const ERGO_CHANGE_PATH = \"m/44'/429'/0'/0\";\n\nexport type FromMnemonicOptions = {\n  passphrase?: string;\n  path?: string;\n};\n\nexport type HDKeyOptions = {\n  depth?: number;\n  index?: number;\n  parentFingerprint?: number;\n  chainCode?: Uint8Array;\n};\n\nexport type PrivateKeyOptions = HDKeyOptions & {\n  privateKey: Uint8Array | bigint;\n};\n\nexport type PublicKeyOptions = HDKeyOptions & {\n  publicKey: Uint8Array;\n};\n\ntype ExtendedErgoKey = ErgoHDKey & { chainCode: Uint8Array };\ntype FullErgoKey = ExtendedErgoKey & {\n  chainCode: Uint8Array;\n  privateKey: Uint8Array;\n};\ntype NeuteredErgoKey = Omit<ErgoHDKey, \"privateKey\" | \"extendedPrivateKey\">;\n\nexport class ErgoHDKey {\n  readonly #root: HDKey;\n  #address?: ErgoAddress;\n\n  constructor(keyOrOpt: HDKey | PrivateKeyOptions | PublicKeyOptions) {\n    this.#root = keyOrOpt instanceof HDKey ? keyOrOpt : new HDKey(keyOrOpt);\n  }\n\n  get publicKey(): Uint8Array {\n    return this.#root.publicKey as Uint8Array;\n  }\n\n  get privateKey(): Uint8Array | undefined {\n    return this.#root.privateKey ?? undefined;\n  }\n\n  get chainCode(): Uint8Array | undefined {\n    return this.#root.chainCode ?? undefined;\n  }\n\n  get extendedPublicKey(): string {\n    return this.#root.publicExtendedKey;\n  }\n\n  get extendedPrivateKey(): string {\n    return this.#root.privateExtendedKey;\n  }\n\n  get index(): number {\n    return this.#root.index;\n  }\n\n  get depth(): number {\n    return this.#root.depth;\n  }\n\n  get address(): ErgoAddress {\n    if (!this.#address) {\n      this.#address = ErgoAddress.fromPublicKey(this.publicKey);\n    }\n\n    return this.#address;\n  }\n\n  static async fromMnemonic(\n    mnemonic: string,\n    options?: FromMnemonicOptions\n  ): Promise<ErgoHDKey> {\n    return ErgoHDKey.fromMasterSeed(\n      await mnemonicToSeed(mnemonic, options?.passphrase),\n      options?.path\n    );\n  }\n\n  static fromMnemonicSync(mnemonic: string, options?: FromMnemonicOptions): ErgoHDKey {\n    return ErgoHDKey.fromMasterSeed(\n      mnemonicToSeedSync(mnemonic, options?.passphrase),\n      options?.path\n    );\n  }\n\n  static fromMasterSeed(seed: Uint8Array, path = ERGO_CHANGE_PATH): ErgoHDKey {\n    const key = HDKey.fromMasterSeed(seed);\n    if (path !== \"\") return new ErgoHDKey(key.derive(path));\n\n    return new ErgoHDKey(key);\n  }\n\n  /**\n   * Create an ErgoHDKey from an extended key\n   * @param encodedKey\n   */\n  static fromExtendedKey(encodedKey: string): ErgoHDKey;\n  /** @deprecated use the default constructor instead */\n  static fromExtendedKey(options: PrivateKeyOptions): ErgoHDKey;\n  /** @deprecated use the default constructor instead */\n  static fromExtendedKey(options: PublicKeyOptions): ErgoHDKey;\n  /** @deprecated use the default constructor instead */\n  static fromExtendedKey(\n    keyOrOptions: string | PrivateKeyOptions | PublicKeyOptions\n  ): ErgoHDKey {\n    if (typeof keyOrOptions !== \"string\") {\n      return new ErgoHDKey(keyOrOptions);\n    }\n\n    const xKey = isHex(keyOrOptions)\n      ? base58check.encode(hex.decode(keyOrOptions))\n      : keyOrOptions;\n    return new ErgoHDKey(HDKey.fromExtendedKey(xKey));\n  }\n\n  deriveChild(index: number): ErgoHDKey {\n    return new ErgoHDKey(this.#root.deriveChild(index));\n  }\n\n  derive(path: string): ErgoHDKey {\n    return new ErgoHDKey(this.#root.derive(path));\n  }\n\n  wipePrivateData(): NeuteredErgoKey {\n    this.#root.wipePrivateData();\n    return this;\n  }\n\n  isExtended(): this is ExtendedErgoKey {\n    return this.chainCode !== undefined;\n  }\n\n  isNeutered(): this is NeuteredErgoKey {\n    return this.privateKey === undefined;\n  }\n\n  hasPrivateKey(): this is FullErgoKey {\n    return this.privateKey !== undefined;\n  }\n}\n","import { generateMnemonic as generate, validateMnemonic as validate } from \"@scure/bip39\";\nimport { wordlist as english } from \"@scure/bip39/wordlists/english\";\n\nexport function generateMnemonic(strength = 160, wordlist = english): string {\n  return generate(wordlist, strength);\n}\n\nexport function validateMnemonic(mnemonic: string, wordlist = english): boolean {\n  return validate(mnemonic, wordlist);\n}\n","import { _0n, concatBytes, FleetError } from \"@fleet-sdk/common\";\nimport {\n  bigintBE,\n  blake2b256,\n  hex,\n  randomBytes,\n  validateEcPoint\n} from \"@fleet-sdk/crypto\";\nimport { secp256k1 } from \"@noble/curves/secp256k1\";\n\nconst { ProjectivePoint: ECPoint, CURVE } = secp256k1;\nconst G = ECPoint.BASE;\n\nconst BLAKE2B_256_DIGEST_LEN = 32;\nconst ERGO_SOUNDNESS_BYTES = 24;\nconst ERGO_SCHNORR_SIG_LEN = BLAKE2B_256_DIGEST_LEN + ERGO_SOUNDNESS_BYTES;\nconst MAX_ITERATIONS = 100;\n\n/**\n * Generates a Schnorr signature for the given message using the provided secret key.\n * @param message - The message to be signed.\n * @param secretKey - The secret key used for signing.\n * @returns The generated signature.\n * @throws FleetError if the signature generation fails after the maximum number of iterations.\n */\nexport function sign(message: Uint8Array, secretKey: Uint8Array) {\n  for (let i = 0; i < MAX_ITERATIONS; i++) {\n    const signature = genSignature(message, secretKey);\n    if (signature) return signature;\n    /* v8 ignore start */\n  }\n\n  // This branch is ignored in the coverage report because it depends on randomness.\n\n  throw new FleetError(\"Failed to generate signature\");\n}\n/* v8 ignore stop */\n\n/**\n * Generates a Schnorr signature for the given message using the provided secret key.\n *\n * @param message - The message to be signed.\n * @param secretKey - The secret key used for signing.\n * @returns The generated signature as a Uint8Array, or undefined if the verification fails.\n * @throws Error if failed to generate commitment.\n */\nexport function genSignature(\n  message: Uint8Array,\n  secretKey: Uint8Array\n): undefined | Uint8Array {\n  const sk = bigintBE.encode(secretKey);\n  const pk = G.multiply(sk).toRawBytes();\n  const r = genRandomSecret();\n  const w = G.multiply(r).toRawBytes();\n  const c = fiatShamirHash(genCommitment(pk, w, message));\n\n  // The next line is ignored in the coverage report because it depends on randomness.\n  /* v8 ignore next */\n  if (c === 0n) throw new FleetError(\"Failed to generate challenge\");\n\n  const z = umod(sk * c + r, CURVE.n);\n  const signature = concatBytes(bigintBE.decode(c), bigintBE.decode(z));\n\n  // The next line is ignored in the coverage report because it depends on randomness.\n  /* v8 ignore next */\n  if (!verify(message, signature, pk)) return;\n\n  return signature;\n}\n\n/**\n * Generates a random value within the range [1, CURVE.n].\n *\n * @returns The generated value.\n * @throws FleetError if failed to generate after reaching the maximum number of iterations.\n */\nfunction genRandomSecret() {\n  let r = 0n;\n  let c = 0;\n\n  while (r === 0n && c < MAX_ITERATIONS) {\n    r = umod(bigintBE.encode(randomBytes(32)), CURVE.n);\n    c++;\n  }\n\n  // The next line is ignored in the coverage report because it depends on randomness.\n  /* v8 ignore next */\n  if (r === 0n) throw new FleetError(\"Failed to generate randomness\");\n\n  return r;\n}\n\n/**\n * Calculates the unsigned modulo of two bigint values.\n * @param a - The dividend.\n * @param b - The divisor.\n */\nexport function umod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n\n/**\n * Verifies the Schnorr signature for a given message using the provided public key and signature.\n * @param message - The message to be verified.\n * @param proof - The proof to be verified.\n * @param publicKey - The public key corresponding to the private key used to generate the signature.\n * @returns A boolean indicating whether the signature is valid or not.\n * @throws FleetError if the public key is invalid.\n */\nexport function verify(message: Uint8Array, proof: Uint8Array, publicKey: Uint8Array) {\n  if (!proof || proof.length !== ERGO_SCHNORR_SIG_LEN) return false;\n  if (!validateEcPoint(publicKey)) throw new FleetError(\"Invalid Public Key.\");\n\n  const pc = bigintBE.encode(proof.slice(0, ERGO_SOUNDNESS_BYTES));\n  const pz = bigintBE.encode(proof.slice(ERGO_SOUNDNESS_BYTES, ERGO_SCHNORR_SIG_LEN));\n\n  const vt = ECPoint.fromHex(publicKey).multiply(CURVE.n - pc);\n  const vw = G.multiply(pz).add(vt).toRawBytes();\n  const vc = fiatShamirHash(genCommitment(publicKey, vw, message));\n\n  return vc === pc;\n}\n\n/**\n * Computes the numeric Fiat-Shamir hash of a given message.\n */\nfunction fiatShamirHash(message: Uint8Array) {\n  return bigintBE.encode(blake2b256(message).slice(0, ERGO_SOUNDNESS_BYTES));\n}\n\nconst COMMITMENT_PREFIX = hex.decode(\"010027100108cd\");\nconst COMMITMENT_POSTFIX = hex.decode(\"73000021\");\n\n/**\n * Generates a commitment for the given public key, w, and message.\n */\nfunction genCommitment(pk: Uint8Array, w: Uint8Array, message: Uint8Array) {\n  return concatBytes(COMMITMENT_PREFIX, pk, COMMITMENT_POSTFIX, w, message);\n}\n","import {\n  type Base58String,\n  type Box,\n  type BoxCandidate,\n  type EIP12UnsignedInput,\n  type EIP12UnsignedTransaction,\n  isHex,\n  type NonMandatoryRegisters,\n  type SignedTransaction,\n  some\n} from \"@fleet-sdk/common\";\nimport { ErgoMessage, ErgoUnsignedTransaction } from \"@fleet-sdk/core\";\nimport { blake2b256, type ByteInput, ensureBytes, hex } from \"@fleet-sdk/crypto\";\nimport {\n  type MinimalUnsignedTransaction,\n  serializeBox,\n  serializeTransaction\n} from \"@fleet-sdk/serializer\";\nimport type { ErgoHDKey } from \"../ergoHDKey\";\nimport { sign, verify } from \"./proveDLogProtocol\";\n\ntype RKey = keyof NonMandatoryRegisters;\nexport type UnsignedTransaction = EIP12UnsignedTransaction | ErgoUnsignedTransaction;\nexport type KeyMap = Record<number, ErgoHDKey> & { _?: ErgoHDKey[] };\n\nexport type Message =\n  | SignedTransaction\n  | ErgoUnsignedTransaction\n  | MinimalUnsignedTransaction\n  | ErgoMessage\n  | ByteInput\n  | Base58String;\n\nexport interface ISigmaProver {\n  signTransaction(unsignedTx: UnsignedTransaction, keys: ErgoHDKey[]): SignedTransaction;\n  signMessage(message: ErgoMessage, key: ErgoHDKey): Uint8Array;\n  verify(message: Message, proof: Uint8Array, publicKey: ErgoHDKey | Uint8Array): boolean;\n}\n\nexport class Prover implements ISigmaProver {\n  signTransaction(\n    message: UnsignedTransaction,\n    keys: ErgoHDKey[] | KeyMap\n  ): SignedTransaction {\n    const getKeyFor = buildKeyMapper(keys);\n    const txData = flattenTransactionObject(message);\n    const txBytes = serializeTransaction(txData).toBytes();\n    const txId = hex.encode(blake2b256(txBytes));\n\n    return {\n      id: txId,\n      inputs: txData.inputs.map((input, index) => ({\n        boxId: input.boxId,\n        spendingProof: {\n          extension: input.extension,\n          proofBytes: hex.encode(generateProof(txBytes, getKeyFor(input, index)))\n        }\n      })),\n      dataInputs: txData.dataInputs.map((x) => ({ boxId: x.boxId })),\n      outputs: txData.outputs.map(mapOutput(txId))\n    };\n  }\n\n  signMessage(message: ErgoMessage, key: ErgoHDKey): Uint8Array {\n    return generateProof(message.serialize().toBytes(), key);\n  }\n\n  verify(message: Message, proof: ByteInput, publicKey: ErgoHDKey | Uint8Array): boolean {\n    let bytes: Uint8Array;\n\n    if (typeof message === \"string\") {\n      bytes = isHex(message)\n        ? hex.decode(message)\n        : ErgoMessage.decode(message).serialize().toBytes();\n    } else if (message instanceof ErgoMessage) {\n      bytes = message.serialize().toBytes();\n    } else if (message instanceof Uint8Array) {\n      bytes = message;\n    } else if (message instanceof ErgoUnsignedTransaction) {\n      bytes = message.toBytes();\n    } else {\n      bytes = serializeTransaction({\n        ...message,\n        inputs: message.inputs.map((input) => ({\n          ...input,\n          extension:\n            \"extension\" in input ? input.extension : input.spendingProof.extension\n        }))\n      }).toBytes();\n    }\n\n    const pubKey = publicKey instanceof Uint8Array ? publicKey : publicKey.publicKey;\n    return verify(bytes, ensureBytes(proof), pubKey);\n  }\n}\n\nfunction buildKeyMapper(keys: ErgoHDKey[] | KeyMap) {\n  const pskMap = new Map<string, ErgoHDKey>();\n\n  // cache encoded public keys\n  const keyMap = isKeyMap(keys) ? keys._ : keys;\n  if (some(keyMap)) {\n    for (const key of keyMap) pskMap.set(hex.encode(key.publicKey), key);\n  }\n\n  return (input: EIP12UnsignedInput, index: number): ErgoHDKey => {\n    if (isKeyMap(keys)) {\n      const secret = keys[index];\n      if (secret) return secret;\n    }\n\n    if (pskMap.size === 1) return pskMap.values().next().value;\n\n    for (const pk of pskMap.keys()) {\n      // try to determine the secret key from the input by checking the ErgoTree and Registers\n      if (includesPubKey(input, pk)) return pskMap.get(pk) as ErgoHDKey;\n    }\n\n    throw new Error(\n      `Unable to find the corresponding secret for the input ${input.index}:${input.boxId}`\n    );\n  };\n}\n\nfunction isKeyMap(keys: ErgoHDKey[] | KeyMap): keys is KeyMap {\n  return !Array.isArray(keys);\n}\n\nfunction includesPubKey(\n  { ergoTree, additionalRegisters: registers }: EIP12UnsignedInput,\n  pubKey: string\n): boolean {\n  return (\n    ergoTree.includes(pubKey) ||\n    (registers &&\n      Object.keys(registers).some((k) => registers[k as RKey]?.includes(pubKey)))\n  );\n}\n\nexport function generateProof(message: Uint8Array, key: ErgoHDKey): Uint8Array {\n  if (!key.privateKey) throw new Error(\"Private key is not present\");\n  return sign(message, key.privateKey);\n}\n\nfunction mapOutput(txId: string) {\n  return (x: BoxCandidate<string>, i: number) => {\n    const box: Box<string> = {\n      boxId: \"\",\n      ...x,\n      transactionId: txId,\n      index: i\n    };\n    box.boxId = hex.encode(blake2b256(serializeBox(box).toBytes()));\n\n    return box;\n  };\n}\n\nfunction flattenTransactionObject(tx: UnsignedTransaction): EIP12UnsignedTransaction {\n  return tx instanceof ErgoUnsignedTransaction ? tx.toEIP12Object() : tx;\n}\n"]}