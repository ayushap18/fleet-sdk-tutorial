import { ErgoAddress, ErgoUnsignedTransaction, ErgoMessage } from '@fleet-sdk/core';
import { HDKey } from '@scure/bip32';
import { EIP12UnsignedTransaction, SignedTransaction, Base58String } from '@fleet-sdk/common';
import { ByteInput } from '@fleet-sdk/crypto';
import { MinimalUnsignedTransaction } from '@fleet-sdk/serializer';

/**
 * Ergo derivation path at change level
 */
declare const ERGO_CHANGE_PATH = "m/44'/429'/0'/0";
type FromMnemonicOptions = {
    passphrase?: string;
    path?: string;
};
type HDKeyOptions = {
    depth?: number;
    index?: number;
    parentFingerprint?: number;
    chainCode?: Uint8Array;
};
type PrivateKeyOptions = HDKeyOptions & {
    privateKey: Uint8Array | bigint;
};
type PublicKeyOptions = HDKeyOptions & {
    publicKey: Uint8Array;
};
type ExtendedErgoKey = ErgoHDKey & {
    chainCode: Uint8Array;
};
type FullErgoKey = ExtendedErgoKey & {
    chainCode: Uint8Array;
    privateKey: Uint8Array;
};
type NeuteredErgoKey = Omit<ErgoHDKey, "privateKey" | "extendedPrivateKey">;
declare class ErgoHDKey {
    #private;
    constructor(keyOrOpt: HDKey | PrivateKeyOptions | PublicKeyOptions);
    get publicKey(): Uint8Array;
    get privateKey(): Uint8Array | undefined;
    get chainCode(): Uint8Array | undefined;
    get extendedPublicKey(): string;
    get extendedPrivateKey(): string;
    get index(): number;
    get depth(): number;
    get address(): ErgoAddress;
    static fromMnemonic(mnemonic: string, options?: FromMnemonicOptions): Promise<ErgoHDKey>;
    static fromMnemonicSync(mnemonic: string, options?: FromMnemonicOptions): ErgoHDKey;
    static fromMasterSeed(seed: Uint8Array, path?: string): ErgoHDKey;
    /**
     * Create an ErgoHDKey from an extended key
     * @param encodedKey
     */
    static fromExtendedKey(encodedKey: string): ErgoHDKey;
    /** @deprecated use the default constructor instead */
    static fromExtendedKey(options: PrivateKeyOptions): ErgoHDKey;
    /** @deprecated use the default constructor instead */
    static fromExtendedKey(options: PublicKeyOptions): ErgoHDKey;
    deriveChild(index: number): ErgoHDKey;
    derive(path: string): ErgoHDKey;
    wipePrivateData(): NeuteredErgoKey;
    isExtended(): this is ExtendedErgoKey;
    isNeutered(): this is NeuteredErgoKey;
    hasPrivateKey(): this is FullErgoKey;
}

declare function generateMnemonic(strength?: number, wordlist?: string[]): string;
declare function validateMnemonic(mnemonic: string, wordlist?: string[]): boolean;

type UnsignedTransaction = EIP12UnsignedTransaction | ErgoUnsignedTransaction;
type KeyMap = Record<number, ErgoHDKey> & {
    _?: ErgoHDKey[];
};
type Message = SignedTransaction | ErgoUnsignedTransaction | MinimalUnsignedTransaction | ErgoMessage | ByteInput | Base58String;
interface ISigmaProver {
    signTransaction(unsignedTx: UnsignedTransaction, keys: ErgoHDKey[]): SignedTransaction;
    signMessage(message: ErgoMessage, key: ErgoHDKey): Uint8Array;
    verify(message: Message, proof: Uint8Array, publicKey: ErgoHDKey | Uint8Array): boolean;
}
declare class Prover implements ISigmaProver {
    signTransaction(message: UnsignedTransaction, keys: ErgoHDKey[] | KeyMap): SignedTransaction;
    signMessage(message: ErgoMessage, key: ErgoHDKey): Uint8Array;
    verify(message: Message, proof: ByteInput, publicKey: ErgoHDKey | Uint8Array): boolean;
}
declare function generateProof(message: Uint8Array, key: ErgoHDKey): Uint8Array;

export { ERGO_CHANGE_PATH, ErgoHDKey, type FromMnemonicOptions, type HDKeyOptions, type ISigmaProver, type KeyMap, type Message, type PrivateKeyOptions, Prover, type PublicKeyOptions, type UnsignedTransaction, generateMnemonic, generateProof, validateMnemonic };
