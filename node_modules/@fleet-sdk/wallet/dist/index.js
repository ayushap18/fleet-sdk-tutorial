'use strict';

var common = require('@fleet-sdk/common');
var core = require('@fleet-sdk/core');
var crypto = require('@fleet-sdk/crypto');
var bip32 = require('@scure/bip32');
var bip39 = require('@scure/bip39');
var english = require('@scure/bip39/wordlists/english');
var serializer = require('@fleet-sdk/serializer');
var secp256k1 = require('@noble/curves/secp256k1');

// src/ergoHDKey.ts
var ERGO_CHANGE_PATH = "m/44'/429'/0'/0";
var ErgoHDKey = class _ErgoHDKey {
  #root;
  #address;
  constructor(keyOrOpt) {
    this.#root = keyOrOpt instanceof bip32.HDKey ? keyOrOpt : new bip32.HDKey(keyOrOpt);
  }
  get publicKey() {
    return this.#root.publicKey;
  }
  get privateKey() {
    return this.#root.privateKey ?? void 0;
  }
  get chainCode() {
    return this.#root.chainCode ?? void 0;
  }
  get extendedPublicKey() {
    return this.#root.publicExtendedKey;
  }
  get extendedPrivateKey() {
    return this.#root.privateExtendedKey;
  }
  get index() {
    return this.#root.index;
  }
  get depth() {
    return this.#root.depth;
  }
  get address() {
    if (!this.#address) {
      this.#address = core.ErgoAddress.fromPublicKey(this.publicKey);
    }
    return this.#address;
  }
  static async fromMnemonic(mnemonic, options) {
    return _ErgoHDKey.fromMasterSeed(
      await bip39.mnemonicToSeed(mnemonic, options?.passphrase),
      options?.path
    );
  }
  static fromMnemonicSync(mnemonic, options) {
    return _ErgoHDKey.fromMasterSeed(
      bip39.mnemonicToSeedSync(mnemonic, options?.passphrase),
      options?.path
    );
  }
  static fromMasterSeed(seed, path = ERGO_CHANGE_PATH) {
    const key = bip32.HDKey.fromMasterSeed(seed);
    if (path !== "") return new _ErgoHDKey(key.derive(path));
    return new _ErgoHDKey(key);
  }
  /** @deprecated use the default constructor instead */
  static fromExtendedKey(keyOrOptions) {
    if (typeof keyOrOptions !== "string") {
      return new _ErgoHDKey(keyOrOptions);
    }
    const xKey = common.isHex(keyOrOptions) ? crypto.base58check.encode(crypto.hex.decode(keyOrOptions)) : keyOrOptions;
    return new _ErgoHDKey(bip32.HDKey.fromExtendedKey(xKey));
  }
  deriveChild(index) {
    return new _ErgoHDKey(this.#root.deriveChild(index));
  }
  derive(path) {
    return new _ErgoHDKey(this.#root.derive(path));
  }
  wipePrivateData() {
    this.#root.wipePrivateData();
    return this;
  }
  isExtended() {
    return this.chainCode !== void 0;
  }
  isNeutered() {
    return this.privateKey === void 0;
  }
  hasPrivateKey() {
    return this.privateKey !== void 0;
  }
};
function generateMnemonic(strength = 160, wordlist = english.wordlist) {
  return bip39.generateMnemonic(wordlist, strength);
}
function validateMnemonic(mnemonic, wordlist = english.wordlist) {
  return bip39.validateMnemonic(mnemonic, wordlist);
}
var { ProjectivePoint: ECPoint, CURVE } = secp256k1.secp256k1;
var G = ECPoint.BASE;
var BLAKE2B_256_DIGEST_LEN = 32;
var ERGO_SOUNDNESS_BYTES = 24;
var ERGO_SCHNORR_SIG_LEN = BLAKE2B_256_DIGEST_LEN + ERGO_SOUNDNESS_BYTES;
var MAX_ITERATIONS = 100;
function sign(message, secretKey) {
  for (let i = 0; i < MAX_ITERATIONS; i++) {
    const signature = genSignature(message, secretKey);
    if (signature) return signature;
  }
  throw new common.FleetError("Failed to generate signature");
}
function genSignature(message, secretKey) {
  const sk = crypto.bigintBE.encode(secretKey);
  const pk = G.multiply(sk).toRawBytes();
  const r = genRandomSecret();
  const w = G.multiply(r).toRawBytes();
  const c = fiatShamirHash(genCommitment(pk, w, message));
  if (c === 0n) throw new common.FleetError("Failed to generate challenge");
  const z = umod(sk * c + r, CURVE.n);
  const signature = common.concatBytes(crypto.bigintBE.decode(c), crypto.bigintBE.decode(z));
  if (!verify(message, signature, pk)) return;
  return signature;
}
function genRandomSecret() {
  let r = 0n;
  let c = 0;
  while (r === 0n && c < MAX_ITERATIONS) {
    r = umod(crypto.bigintBE.encode(crypto.randomBytes(32)), CURVE.n);
    c++;
  }
  if (r === 0n) throw new common.FleetError("Failed to generate randomness");
  return r;
}
function umod(a, b) {
  const result = a % b;
  return result >= common._0n ? result : b + result;
}
function verify(message, proof, publicKey) {
  if (!proof || proof.length !== ERGO_SCHNORR_SIG_LEN) return false;
  if (!crypto.validateEcPoint(publicKey)) throw new common.FleetError("Invalid Public Key.");
  const pc = crypto.bigintBE.encode(proof.slice(0, ERGO_SOUNDNESS_BYTES));
  const pz = crypto.bigintBE.encode(proof.slice(ERGO_SOUNDNESS_BYTES, ERGO_SCHNORR_SIG_LEN));
  const vt = ECPoint.fromHex(publicKey).multiply(CURVE.n - pc);
  const vw = G.multiply(pz).add(vt).toRawBytes();
  const vc = fiatShamirHash(genCommitment(publicKey, vw, message));
  return vc === pc;
}
function fiatShamirHash(message) {
  return crypto.bigintBE.encode(crypto.blake2b256(message).slice(0, ERGO_SOUNDNESS_BYTES));
}
var COMMITMENT_PREFIX = crypto.hex.decode("010027100108cd");
var COMMITMENT_POSTFIX = crypto.hex.decode("73000021");
function genCommitment(pk, w, message) {
  return common.concatBytes(COMMITMENT_PREFIX, pk, COMMITMENT_POSTFIX, w, message);
}

// src/prover/prover.ts
var Prover = class {
  signTransaction(message, keys) {
    const getKeyFor = buildKeyMapper(keys);
    const txData = flattenTransactionObject(message);
    const txBytes = serializer.serializeTransaction(txData).toBytes();
    const txId = crypto.hex.encode(crypto.blake2b256(txBytes));
    return {
      id: txId,
      inputs: txData.inputs.map((input, index) => ({
        boxId: input.boxId,
        spendingProof: {
          extension: input.extension,
          proofBytes: crypto.hex.encode(generateProof(txBytes, getKeyFor(input, index)))
        }
      })),
      dataInputs: txData.dataInputs.map((x) => ({ boxId: x.boxId })),
      outputs: txData.outputs.map(mapOutput(txId))
    };
  }
  signMessage(message, key) {
    return generateProof(message.serialize().toBytes(), key);
  }
  verify(message, proof, publicKey) {
    let bytes;
    if (typeof message === "string") {
      bytes = common.isHex(message) ? crypto.hex.decode(message) : core.ErgoMessage.decode(message).serialize().toBytes();
    } else if (message instanceof core.ErgoMessage) {
      bytes = message.serialize().toBytes();
    } else if (message instanceof Uint8Array) {
      bytes = message;
    } else if (message instanceof core.ErgoUnsignedTransaction) {
      bytes = message.toBytes();
    } else {
      bytes = serializer.serializeTransaction({
        ...message,
        inputs: message.inputs.map((input) => ({
          ...input,
          extension: "extension" in input ? input.extension : input.spendingProof.extension
        }))
      }).toBytes();
    }
    const pubKey = publicKey instanceof Uint8Array ? publicKey : publicKey.publicKey;
    return verify(bytes, crypto.ensureBytes(proof), pubKey);
  }
};
function buildKeyMapper(keys) {
  const pskMap = /* @__PURE__ */ new Map();
  const keyMap = isKeyMap(keys) ? keys._ : keys;
  if (common.some(keyMap)) {
    for (const key of keyMap) pskMap.set(crypto.hex.encode(key.publicKey), key);
  }
  return (input, index) => {
    if (isKeyMap(keys)) {
      const secret = keys[index];
      if (secret) return secret;
    }
    if (pskMap.size === 1) return pskMap.values().next().value;
    for (const pk of pskMap.keys()) {
      if (includesPubKey(input, pk)) return pskMap.get(pk);
    }
    throw new Error(
      `Unable to find the corresponding secret for the input ${input.index}:${input.boxId}`
    );
  };
}
function isKeyMap(keys) {
  return !Array.isArray(keys);
}
function includesPubKey({ ergoTree, additionalRegisters: registers }, pubKey) {
  return ergoTree.includes(pubKey) || registers && Object.keys(registers).some((k) => registers[k]?.includes(pubKey));
}
function generateProof(message, key) {
  if (!key.privateKey) throw new Error("Private key is not present");
  return sign(message, key.privateKey);
}
function mapOutput(txId) {
  return (x, i) => {
    const box = {
      boxId: "",
      ...x,
      transactionId: txId,
      index: i
    };
    box.boxId = crypto.hex.encode(crypto.blake2b256(serializer.serializeBox(box).toBytes()));
    return box;
  };
}
function flattenTransactionObject(tx) {
  return tx instanceof core.ErgoUnsignedTransaction ? tx.toEIP12Object() : tx;
}

exports.ERGO_CHANGE_PATH = ERGO_CHANGE_PATH;
exports.ErgoHDKey = ErgoHDKey;
exports.Prover = Prover;
exports.generateMnemonic = generateMnemonic;
exports.generateProof = generateProof;
exports.validateMnemonic = validateMnemonic;
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map