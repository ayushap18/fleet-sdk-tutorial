import { isHex, some, FleetError, concatBytes, _0n } from '@fleet-sdk/common';
import { ErgoAddress, ErgoMessage, ErgoUnsignedTransaction } from '@fleet-sdk/core';
import { hex, base58check, blake2b256, ensureBytes, bigintBE, randomBytes, validateEcPoint } from '@fleet-sdk/crypto';
import { HDKey } from '@scure/bip32';
import { mnemonicToSeed, mnemonicToSeedSync, generateMnemonic as generateMnemonic$1, validateMnemonic as validateMnemonic$1 } from '@scure/bip39';
import { wordlist } from '@scure/bip39/wordlists/english';
import { serializeTransaction, serializeBox } from '@fleet-sdk/serializer';
import { secp256k1 } from '@noble/curves/secp256k1';

// src/ergoHDKey.ts
var ERGO_CHANGE_PATH = "m/44'/429'/0'/0";
var ErgoHDKey = class _ErgoHDKey {
  #root;
  #address;
  constructor(keyOrOpt) {
    this.#root = keyOrOpt instanceof HDKey ? keyOrOpt : new HDKey(keyOrOpt);
  }
  get publicKey() {
    return this.#root.publicKey;
  }
  get privateKey() {
    return this.#root.privateKey ?? void 0;
  }
  get chainCode() {
    return this.#root.chainCode ?? void 0;
  }
  get extendedPublicKey() {
    return this.#root.publicExtendedKey;
  }
  get extendedPrivateKey() {
    return this.#root.privateExtendedKey;
  }
  get index() {
    return this.#root.index;
  }
  get depth() {
    return this.#root.depth;
  }
  get address() {
    if (!this.#address) {
      this.#address = ErgoAddress.fromPublicKey(this.publicKey);
    }
    return this.#address;
  }
  static async fromMnemonic(mnemonic, options) {
    return _ErgoHDKey.fromMasterSeed(
      await mnemonicToSeed(mnemonic, options?.passphrase),
      options?.path
    );
  }
  static fromMnemonicSync(mnemonic, options) {
    return _ErgoHDKey.fromMasterSeed(
      mnemonicToSeedSync(mnemonic, options?.passphrase),
      options?.path
    );
  }
  static fromMasterSeed(seed, path = ERGO_CHANGE_PATH) {
    const key = HDKey.fromMasterSeed(seed);
    if (path !== "") return new _ErgoHDKey(key.derive(path));
    return new _ErgoHDKey(key);
  }
  /** @deprecated use the default constructor instead */
  static fromExtendedKey(keyOrOptions) {
    if (typeof keyOrOptions !== "string") {
      return new _ErgoHDKey(keyOrOptions);
    }
    const xKey = isHex(keyOrOptions) ? base58check.encode(hex.decode(keyOrOptions)) : keyOrOptions;
    return new _ErgoHDKey(HDKey.fromExtendedKey(xKey));
  }
  deriveChild(index) {
    return new _ErgoHDKey(this.#root.deriveChild(index));
  }
  derive(path) {
    return new _ErgoHDKey(this.#root.derive(path));
  }
  wipePrivateData() {
    this.#root.wipePrivateData();
    return this;
  }
  isExtended() {
    return this.chainCode !== void 0;
  }
  isNeutered() {
    return this.privateKey === void 0;
  }
  hasPrivateKey() {
    return this.privateKey !== void 0;
  }
};
function generateMnemonic(strength = 160, wordlist$1 = wordlist) {
  return generateMnemonic$1(wordlist$1, strength);
}
function validateMnemonic(mnemonic, wordlist$1 = wordlist) {
  return validateMnemonic$1(mnemonic, wordlist$1);
}
var { ProjectivePoint: ECPoint, CURVE } = secp256k1;
var G = ECPoint.BASE;
var BLAKE2B_256_DIGEST_LEN = 32;
var ERGO_SOUNDNESS_BYTES = 24;
var ERGO_SCHNORR_SIG_LEN = BLAKE2B_256_DIGEST_LEN + ERGO_SOUNDNESS_BYTES;
var MAX_ITERATIONS = 100;
function sign(message, secretKey) {
  for (let i = 0; i < MAX_ITERATIONS; i++) {
    const signature = genSignature(message, secretKey);
    if (signature) return signature;
  }
  throw new FleetError("Failed to generate signature");
}
function genSignature(message, secretKey) {
  const sk = bigintBE.encode(secretKey);
  const pk = G.multiply(sk).toRawBytes();
  const r = genRandomSecret();
  const w = G.multiply(r).toRawBytes();
  const c = fiatShamirHash(genCommitment(pk, w, message));
  if (c === 0n) throw new FleetError("Failed to generate challenge");
  const z = umod(sk * c + r, CURVE.n);
  const signature = concatBytes(bigintBE.decode(c), bigintBE.decode(z));
  if (!verify(message, signature, pk)) return;
  return signature;
}
function genRandomSecret() {
  let r = 0n;
  let c = 0;
  while (r === 0n && c < MAX_ITERATIONS) {
    r = umod(bigintBE.encode(randomBytes(32)), CURVE.n);
    c++;
  }
  if (r === 0n) throw new FleetError("Failed to generate randomness");
  return r;
}
function umod(a, b) {
  const result = a % b;
  return result >= _0n ? result : b + result;
}
function verify(message, proof, publicKey) {
  if (!proof || proof.length !== ERGO_SCHNORR_SIG_LEN) return false;
  if (!validateEcPoint(publicKey)) throw new FleetError("Invalid Public Key.");
  const pc = bigintBE.encode(proof.slice(0, ERGO_SOUNDNESS_BYTES));
  const pz = bigintBE.encode(proof.slice(ERGO_SOUNDNESS_BYTES, ERGO_SCHNORR_SIG_LEN));
  const vt = ECPoint.fromHex(publicKey).multiply(CURVE.n - pc);
  const vw = G.multiply(pz).add(vt).toRawBytes();
  const vc = fiatShamirHash(genCommitment(publicKey, vw, message));
  return vc === pc;
}
function fiatShamirHash(message) {
  return bigintBE.encode(blake2b256(message).slice(0, ERGO_SOUNDNESS_BYTES));
}
var COMMITMENT_PREFIX = hex.decode("010027100108cd");
var COMMITMENT_POSTFIX = hex.decode("73000021");
function genCommitment(pk, w, message) {
  return concatBytes(COMMITMENT_PREFIX, pk, COMMITMENT_POSTFIX, w, message);
}

// src/prover/prover.ts
var Prover = class {
  signTransaction(message, keys) {
    const getKeyFor = buildKeyMapper(keys);
    const txData = flattenTransactionObject(message);
    const txBytes = serializeTransaction(txData).toBytes();
    const txId = hex.encode(blake2b256(txBytes));
    return {
      id: txId,
      inputs: txData.inputs.map((input, index) => ({
        boxId: input.boxId,
        spendingProof: {
          extension: input.extension,
          proofBytes: hex.encode(generateProof(txBytes, getKeyFor(input, index)))
        }
      })),
      dataInputs: txData.dataInputs.map((x) => ({ boxId: x.boxId })),
      outputs: txData.outputs.map(mapOutput(txId))
    };
  }
  signMessage(message, key) {
    return generateProof(message.serialize().toBytes(), key);
  }
  verify(message, proof, publicKey) {
    let bytes;
    if (typeof message === "string") {
      bytes = isHex(message) ? hex.decode(message) : ErgoMessage.decode(message).serialize().toBytes();
    } else if (message instanceof ErgoMessage) {
      bytes = message.serialize().toBytes();
    } else if (message instanceof Uint8Array) {
      bytes = message;
    } else if (message instanceof ErgoUnsignedTransaction) {
      bytes = message.toBytes();
    } else {
      bytes = serializeTransaction({
        ...message,
        inputs: message.inputs.map((input) => ({
          ...input,
          extension: "extension" in input ? input.extension : input.spendingProof.extension
        }))
      }).toBytes();
    }
    const pubKey = publicKey instanceof Uint8Array ? publicKey : publicKey.publicKey;
    return verify(bytes, ensureBytes(proof), pubKey);
  }
};
function buildKeyMapper(keys) {
  const pskMap = /* @__PURE__ */ new Map();
  const keyMap = isKeyMap(keys) ? keys._ : keys;
  if (some(keyMap)) {
    for (const key of keyMap) pskMap.set(hex.encode(key.publicKey), key);
  }
  return (input, index) => {
    if (isKeyMap(keys)) {
      const secret = keys[index];
      if (secret) return secret;
    }
    if (pskMap.size === 1) return pskMap.values().next().value;
    for (const pk of pskMap.keys()) {
      if (includesPubKey(input, pk)) return pskMap.get(pk);
    }
    throw new Error(
      `Unable to find the corresponding secret for the input ${input.index}:${input.boxId}`
    );
  };
}
function isKeyMap(keys) {
  return !Array.isArray(keys);
}
function includesPubKey({ ergoTree, additionalRegisters: registers }, pubKey) {
  return ergoTree.includes(pubKey) || registers && Object.keys(registers).some((k) => registers[k]?.includes(pubKey));
}
function generateProof(message, key) {
  if (!key.privateKey) throw new Error("Private key is not present");
  return sign(message, key.privateKey);
}
function mapOutput(txId) {
  return (x, i) => {
    const box = {
      boxId: "",
      ...x,
      transactionId: txId,
      index: i
    };
    box.boxId = hex.encode(blake2b256(serializeBox(box).toBytes()));
    return box;
  };
}
function flattenTransactionObject(tx) {
  return tx instanceof ErgoUnsignedTransaction ? tx.toEIP12Object() : tx;
}

export { ERGO_CHANGE_PATH, ErgoHDKey, Prover, generateMnemonic, generateProof, validateMnemonic };
//# sourceMappingURL=index.mjs.map
//# sourceMappingURL=index.mjs.map