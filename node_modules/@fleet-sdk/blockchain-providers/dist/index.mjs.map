{"version":3,"sources":["../../../node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/src/utils.ts","../../crypto/src/coders/hex.ts","../src/utils/networking.ts","../src/utils/graphql.ts","../src/ergo-graphql/queries.ts","../src/ergo-graphql/ergoGraphQLProvider.ts"],"names":["bytes","hex","response","some","isEmpty","query","chunk","ensureDefaults"],"mappings":"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","file":"index.mjs","sourcesContent":["/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { bytes as abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\n  );\n}\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word: number, shift: number) =>\n  (word << shift) | ((word >>> (32 - shift)) >>> 0);\n\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nexport const byteSwap = (word: number) =>\n  ((word << 24) & 0xff000000) |\n  ((word << 8) & 0xff0000) |\n  ((word >>> 8) & 0xff00) |\n  ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n: number) => n : (n: number) => byteSwap(n);\n\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr: Uint32Array) {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n}\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 } as const;\nfunction asciiToBase16(char: number): number | undefined {\n  if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n  if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n  if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\nconst toStr = {}.toString;\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","import { assert, assertInstanceOf, assertTypeOf } from \"@fleet-sdk/common\";\nimport type { BytesCoder } from \"../types\";\n\nconst HEXES = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, \"0\"));\n\nconst HexChar = {\n  ZERO: 48, // 0\n  NINE: 57, // 9\n  A_UP: 65, // A\n  F_UP: 70, // F\n  A_LO: 97, // a\n  F_LO: 102 // f\n} as const;\n\nfunction bytesToHex(bytes: Uint8Array): string {\n  assertInstanceOf(bytes, Uint8Array);\n\n  let hex = \"\";\n  for (let i = 0, len = bytes.length; i < len; i++) {\n    hex += HEXES[bytes[i]];\n  }\n\n  return hex;\n}\n\nfunction hexToBytes(hex: string): Uint8Array {\n  assertTypeOf(hex, \"string\");\n  assert(hex.length % 2 === 0, \"Invalid hex padding.\");\n\n  const len = hex.length / 2;\n  const bytes = new Uint8Array(len);\n  for (let i = 0, j = 0; i < len; i++) {\n    const n1 = charCodeToBase16(hex.charCodeAt(j++));\n    const n2 = charCodeToBase16(hex.charCodeAt(j++));\n    bytes[i] = n1 * 16 + n2;\n  }\n\n  return bytes;\n}\n\nfunction charCodeToBase16(char: number) {\n  if (char >= HexChar.ZERO && char <= HexChar.NINE) return char - HexChar.ZERO;\n  if (char >= HexChar.A_UP && char <= HexChar.F_UP) return char - (HexChar.A_UP - 10);\n  if (char >= HexChar.A_LO && char <= HexChar.F_LO) return char - (HexChar.A_LO - 10);\n\n  throw new Error(\"Invalid byte sequence.\");\n}\n\nexport const hex: BytesCoder = {\n  encode: bytesToHex,\n  decode: hexToBytes\n};\n","import { some } from \"@fleet-sdk/common\";\n\nexport interface ParserLike {\n  parse<T>(text: string): T;\n  stringify<T>(value: T): string;\n}\n\nexport type Route = { base: string; path: string; query?: Record<string, unknown> };\nexport type URLLike = string | Route;\nexport type FallbackRetryOptions = { fallbacks?: URLLike[] } & RetryOptions;\n\nexport type FetchOptions = {\n  parser?: ParserLike;\n  base?: string;\n  query?: Record<string, unknown>;\n  retry?: FallbackRetryOptions;\n  httpOptions?: RequestInit;\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\nconst RETRY_STATUS_CODES = new Set([\n  408, // Request Timeout\n  409, // Conflict\n  425, // Too Early (Experimental)\n  429, // Too Many Requests\n  500, // Internal Server Error\n  502, // Bad Gateway\n  503, // Service Unavailable\n  504 // Gateway Timeout\n]);\n\nexport async function request<T>(path: string, opt?: Partial<FetchOptions>): Promise<T> {\n  const url = buildURL(path, opt?.query, opt?.base);\n\n  let response: Response;\n  if (opt?.retry) {\n    const routes = some(opt.retry.fallbacks) ? [url, ...opt.retry.fallbacks] : [url];\n    const attempts = opt.retry.attempts;\n    response = await exponentialRetry(async (r) => {\n      const response = await fetch(resolveUrl(routes, attempts - r), opt.httpOptions);\n      if (RETRY_STATUS_CODES.has(response.status)) throw new Error(response.statusText);\n\n      return response;\n    }, opt.retry);\n  } else {\n    response = await fetch(url, opt?.httpOptions);\n  }\n\n  return (opt?.parser || JSON).parse(await response.text());\n}\n\nfunction resolveUrl(routes: URLLike[], attempt: number) {\n  const route = routes[attempt % routes.length];\n  return typeof route === \"string\"\n    ? route\n    : buildURL(route.path, route.query, route.base).toString();\n}\n\nfunction buildURL(path: string, query?: Record<string, unknown>, base?: string) {\n  if (!base && !query) return path;\n\n  const url = new URL(path, base);\n  if (some(query)) {\n    for (const key in query) url.searchParams.append(key, String(query[key]));\n  }\n\n  return url.toString();\n}\n\nexport type RetryOptions = {\n  attempts: number;\n  delay: number;\n};\n\n/**\n * Retries an asynchronous operation a specified number of times with a delay\n * growing exponentially between each attempt.\n * @param operation - The asynchronous operation to retry.\n * @param options - The retry options.\n * @returns A promise that resolves to the result of the operation, or undefined\n * if all attempts fail.\n */\nexport async function exponentialRetry<T>(\n  operation: (remainingAttempts: number) => Promise<T>,\n  { attempts, delay }: RetryOptions\n): Promise<T> {\n  try {\n    return await operation(attempts);\n  } catch (e) {\n    if (attempts > 0) {\n      await new Promise((resolve) => setTimeout(resolve, delay));\n      return exponentialRetry(operation, { attempts: attempts - 1, delay: delay * 2 });\n    }\n\n    throw e;\n  }\n}\n","import {\n  BlockchainProviderError,\n  clearUndefined,\n  ensureDefaults,\n  isEmpty,\n  some\n} from \"@fleet-sdk/common\";\nimport type { FallbackRetryOptions, ParserLike } from \"./networking\";\nimport { request } from \"./networking\";\n\nconst OP_NAME_REGEX = /(query|mutation)\\s?([\\w\\-_]+)?/;\nconst DEFAULT_HEADERS = {\n  \"content-type\": \"application/json; charset=utf-8\",\n  accept: \"application/graphql-response+json, application/json\"\n};\n\nexport type GraphQLVariables = Record<string, unknown> | null;\n\nexport interface GraphQLError {\n  message: string;\n}\n\nexport interface GraphQLSuccessResponse<T = unknown> {\n  data: T;\n  errors: null;\n}\n\nexport interface GraphQLErrorResponse {\n  data: null;\n  errors: GraphQLError[];\n}\n\nexport type GraphQLResponse<T = unknown> =\n  | GraphQLSuccessResponse<T>\n  | GraphQLErrorResponse;\n\nexport type GraphQLOperation<R extends GraphQLResponse, V extends GraphQLVariables> = (\n  variables?: V,\n  url?: string\n) => Promise<R>;\n\nexport type GraphQLRequiredUrlOperation<\n  R extends GraphQLResponse,\n  V extends GraphQLVariables\n> = (variables: V | undefined, url: string) => Promise<R>;\n\ninterface RequestParams {\n  operationName?: string | null;\n  query: string;\n  variables?: Record<string, unknown> | null;\n}\n\nexport interface GraphQLRequestOptions {\n  url?: string;\n  parser?: ParserLike;\n  retry?: FallbackRetryOptions;\n  throwOnNonNetworkErrors?: boolean;\n  httpOptions?: Omit<RequestInit, \"body\" | \"method\">;\n}\n\nexport function createGqlOperation<R, V extends GraphQLVariables = GraphQLVariables>(\n  query: string,\n  options: GraphQLRequestOptions & { throwOnNonNetworkErrors: true }\n): GraphQLOperation<GraphQLSuccessResponse<R>, V>;\nexport function createGqlOperation<R, V extends GraphQLVariables = GraphQLVariables>(\n  query: string,\n  options?: GraphQLRequestOptions & { url: undefined }\n): GraphQLRequiredUrlOperation<GraphQLResponse<R>, V>;\nexport function createGqlOperation<R, V extends GraphQLVariables = GraphQLVariables>(\n  query: string,\n  options: GraphQLRequestOptions & { url: undefined; throwOnNonNetworkErrors: true }\n): GraphQLRequiredUrlOperation<GraphQLSuccessResponse<R>, V>;\nexport function createGqlOperation<R, V extends GraphQLVariables = GraphQLVariables>(\n  query: string,\n  options: GraphQLRequestOptions\n): GraphQLOperation<GraphQLResponse<R>, V>;\nexport function createGqlOperation<R, V extends GraphQLVariables = GraphQLVariables>(\n  query: string,\n  options?: GraphQLRequestOptions\n):\n  | GraphQLOperation<GraphQLResponse<R>, V>\n  | GraphQLRequiredUrlOperation<GraphQLResponse<R>, V> {\n  return async (variables?: V, url?: string): Promise<GraphQLResponse<R>> => {\n    url = url ?? options?.url;\n    if (!url) throw new Error(\"URL is required\");\n\n    const response = await request<GraphQLResponse<R>>(url, {\n      ...options,\n      httpOptions: {\n        ...options?.httpOptions,\n        method: \"POST\",\n        headers: ensureDefaults(options?.httpOptions?.headers, DEFAULT_HEADERS),\n        body: (options?.parser ?? JSON).stringify({\n          operationName: getOpName(query),\n          query,\n          variables: variables ? clearUndefined(variables) : undefined\n        } as RequestParams)\n      }\n    });\n\n    if (\n      options?.throwOnNonNetworkErrors &&\n      some(response.errors) &&\n      isEmpty(response.data)\n    ) {\n      const msg = response.errors[0].message;\n      throw new BlockchainProviderError(msg, { cause: response.errors });\n    }\n\n    return response;\n  };\n}\n\nexport function gql(query: TemplateStringsArray): string {\n  return query[0];\n}\n\nexport function getOpName(query: string): string | undefined {\n  return OP_NAME_REGEX.exec(query)?.at(2);\n}\n","const B = [\n  \"$boxIds: [String!] $ergoTrees: [String!] $ergoTreeTemplateHash: String $tokenId: String $skip: Int $take: Int\",\n  \"boxIds: $boxIds ergoTrees: $ergoTrees ergoTreeTemplateHash: $ergoTreeTemplateHash tokenId: $tokenId skip: $skip take: $take\",\n  \"boxId transactionId index value creationHeight ergoTree assets { tokenId amount } additionalRegisters\"\n];\n\nexport const CONF_BOXES_QUERY = `query boxes($spent: Boolean! ${B[0]}) { boxes(spent: $spent ${B[1]}) { ${B[2]} beingSpent } }`;\nexport const UNCONF_BOXES_QUERY = `query boxes(${B[0]}) { mempool { boxes(${B[1]}) { ${B[2]} beingSpent } } }`;\nexport const ALL_BOXES_QUERY = `query boxes($spent: Boolean! ${B[0]}) { boxes(spent: $spent ${B[1]}) { ${B[2]} beingSpent } mempool { boxes(${B[1]}) { ${B[2]} beingSpent } } }`;\n\nexport const HEADERS_QUERY =\n  \"query blockHeaders($take: Int) { blockHeaders(take: $take) {headerId timestamp version adProofsRoot stateRoot transactionsRoot nBits extensionHash powSolutions height difficulty parentId votes } }\";\nexport const CHECK_TX_MUTATION =\n  \"mutation checkTransaction($signedTransaction: SignedTransaction!) { checkTransaction(signedTransaction: $signedTransaction) }\";\nexport const SEND_TX_MUTATION =\n  \"mutation submitTransaction($signedTransaction: SignedTransaction!) { submitTransaction(signedTransaction: $signedTransaction) }\";\n\nconst T = [\n  \"$addresses: [String!], $transactionIds: [String!], $skip: Int, $take: Int\",\n  \"addresses: $addresses, transactionIds: $transactionIds, skip: $skip, take: $take\",\n  `transactionId timestamp inputs { proofBytes extension index box { ${B[2]} } } dataInputs { boxId }`\n];\nexport const CONF_TX_QUERY = `query confirmedTransactions(${T[0]}  $onlyRelevantOutputs: Boolean) { transactions(${T[1]}) { ${T[2]} outputs(relevantOnly: $onlyRelevantOutputs) { ${B[2]} } inclusionHeight headerId index } }`;\nexport const UNCONF_TX_QUERY = `query unconfirmedTransactions(${T[0]}) { mempool { transactions(${T[1]}) { ${T[2]} outputs { ${B[2]} } } } }`;\n","import type {\n  Box as GQLBox,\n  QueryBoxesArgs,\n  Header,\n  QueryBlockHeadersArgs,\n  Transaction,\n  QueryTransactionsArgs,\n  MempoolTransactionsArgs,\n  UnconfirmedTransaction,\n  UnconfirmedBox as GQLUnconfirmedBox\n} from \"@ergo-graphql/types\";\nimport {\n  type Base58String,\n  type BlockHeader,\n  type HexString,\n  type SignedTransaction,\n  ensureDefaults,\n  isEmpty,\n  isUndefined,\n  NotSupportedError,\n  orderBy,\n  some,\n  uniq,\n  uniqBy,\n  chunk\n} from \"@fleet-sdk/common\";\nimport { ErgoAddress } from \"@fleet-sdk/core\";\nimport { hex } from \"@fleet-sdk/crypto\";\nimport type {\n  BoxQuery,\n  BoxWhere,\n  ChainProviderBox,\n  ChainProviderConfirmedTransaction,\n  ChainProviderUnconfirmedTransaction,\n  HeaderQuery,\n  IBlockchainProvider,\n  TransactionEvaluationResult,\n  TransactionQuery,\n  TransactionReductionResult,\n  ConfirmedTransactionWhere,\n  UnconfirmedTransactionWhere\n} from \"../types/blockchainProvider\";\nimport {\n  type GraphQLOperation,\n  type GraphQLRequestOptions,\n  type GraphQLSuccessResponse,\n  type GraphQLVariables,\n  createGqlOperation\n} from \"../utils\";\nimport {\n  ALL_BOXES_QUERY,\n  CHECK_TX_MUTATION,\n  CONF_BOXES_QUERY,\n  CONF_TX_QUERY,\n  HEADERS_QUERY,\n  SEND_TX_MUTATION,\n  UNCONF_BOXES_QUERY,\n  UNCONF_TX_QUERY\n} from \"./queries\";\n\ntype SkipAndTake = { skip?: number; take?: number };\n\nexport type GraphQLBoxWhere = BoxWhere & {\n  /** Base16-encoded ErgoTrees */\n  ergoTrees?: HexString[];\n\n  /** Base58-encoded addresses or `ErgoAddress` objects */\n  addresses?: (Base58String | ErgoAddress)[];\n};\n\nexport type GraphQLConfirmedTransactionWhere = ConfirmedTransactionWhere & {\n  addresses?: (Base58String | ErgoAddress)[];\n  ergoTrees?: HexString[];\n};\n\nexport type GraphQLUnconfirmedTransactionWhere = UnconfirmedTransactionWhere & {\n  addresses?: (Base58String | ErgoAddress)[];\n  ergoTrees?: HexString[];\n};\n\nexport type GraphQLBoxQuery = BoxQuery<GraphQLBoxWhere>;\nexport type ErgoGraphQLRequestOptions = Omit<\n  GraphQLRequestOptions,\n  \"throwOnNonNetworkErrors\"\n>;\n\ntype ConfirmedBoxesResponse = { boxes: GQLBox[] };\ntype UnconfirmedBoxesResponse = { mempool: { boxes: GQLBox[] } };\ntype CombinedBoxesResponse = ConfirmedBoxesResponse & UnconfirmedBoxesResponse;\ntype UnconfirmedTxResponse = { mempool: { transactions: UnconfirmedTransaction[] } };\ntype ConfirmedTxResponse = { transactions: Transaction[] };\ntype BlockHeadersResponse = { blockHeaders: Header[] };\ntype CheckTransactionResponse = { checkTransaction: string };\ntype TransactionSubmissionResponse = { submitTransaction: string };\ntype SignedTxArgsResp = { signedTransaction: SignedTransaction };\n\ntype GraphQLThrowableOptions = ErgoGraphQLRequestOptions & {\n  throwOnNonNetworkErrors: true;\n};\n\ntype OP<R, V extends GraphQLVariables> = GraphQLOperation<GraphQLSuccessResponse<R>, V>;\ntype BiMapper<T> = (value: string) => T;\n\nconst PAGE_SIZE = 50;\nconst MAX_ARGS = 20;\n\nexport class ErgoGraphQLProvider<I = bigint> implements IBlockchainProvider<I> {\n  #options: GraphQLThrowableOptions;\n  #biMapper: BiMapper<I>;\n\n  #getConfirmedBoxes: OP<ConfirmedBoxesResponse, QueryBoxesArgs>;\n  #getUnconfirmedBoxes: OP<UnconfirmedBoxesResponse, QueryBoxesArgs>;\n  #getAllBoxes: OP<CombinedBoxesResponse, QueryBoxesArgs>;\n  #getConfirmedTransactions: OP<ConfirmedTxResponse, QueryTransactionsArgs>;\n  #getUnconfirmedTransactions: OP<UnconfirmedTxResponse, MempoolTransactionsArgs>;\n  #checkTransaction: OP<CheckTransactionResponse, SignedTxArgsResp>;\n  #sendTransaction: OP<TransactionSubmissionResponse, SignedTxArgsResp>;\n  #getHeaders!: OP<BlockHeadersResponse, QueryBlockHeadersArgs>;\n\n  constructor(url: string);\n  constructor(options: ErgoGraphQLRequestOptions);\n  constructor(optOrUrl: ErgoGraphQLRequestOptions | string) {\n    this.#biMapper = (value) => BigInt(value) as I;\n    this.#options = {\n      ...(isRequestParam(optOrUrl) ? optOrUrl : { url: optOrUrl }),\n      throwOnNonNetworkErrors: true\n    };\n\n    this.#getConfirmedBoxes = this.createOperation(CONF_BOXES_QUERY);\n    this.#getUnconfirmedBoxes = this.createOperation(UNCONF_BOXES_QUERY);\n    this.#getAllBoxes = this.createOperation(ALL_BOXES_QUERY);\n    this.#getConfirmedTransactions = this.createOperation(CONF_TX_QUERY);\n    this.#getUnconfirmedTransactions = this.createOperation(UNCONF_TX_QUERY);\n    this.#checkTransaction = this.createOperation(CHECK_TX_MUTATION);\n    this.#sendTransaction = this.createOperation(SEND_TX_MUTATION);\n    this.#getHeaders = this.createOperation(HEADERS_QUERY);\n  }\n\n  #fetchBoxes(args: QueryBoxesArgs, inclConf: boolean, inclUnconf: boolean) {\n    return inclConf && inclUnconf\n      ? this.#getAllBoxes(args)\n      : inclUnconf\n        ? this.#getUnconfirmedBoxes(args)\n        : this.#getConfirmedBoxes(args);\n  }\n\n  setUrl(url: string): ErgoGraphQLProvider<I> {\n    this.#options.url = url;\n    return this;\n  }\n\n  setBigIntMapper<M>(mapper: BiMapper<M>): ErgoGraphQLProvider<M> {\n    this.#biMapper = mapper as unknown as BiMapper<I>;\n    return this as unknown as ErgoGraphQLProvider<M>;\n  }\n\n  async *streamBoxes(\n    query: GraphQLBoxQuery & SkipAndTake\n  ): AsyncGenerator<ChainProviderBox<I>[]> {\n    if (isEmpty(query.where)) {\n      throw new Error(\"Cannot fetch unspent boxes without a where clause.\");\n    }\n\n    const notBeingSpent = (box: GQLBox) => !box.beingSpent;\n    const returnedBoxIds = new Set<string>();\n    const { from, take } = query;\n    const pageSize = take ?? PAGE_SIZE;\n    const queries = buildGqlBoxQueries(query);\n    const isMempoolAware = from !== \"blockchain\";\n\n    for (const query of queries) {\n      let inclChain = from !== \"mempool\";\n      let inclPool = from !== \"blockchain\";\n\n      while (inclChain || inclPool) {\n        const { data } = await this.#fetchBoxes(query, inclChain, inclPool);\n        let boxes: ChainProviderBox<I>[] = [];\n\n        if (inclChain && hasConfirmed(data)) {\n          if (some(data.boxes)) {\n            const confirmedBoxes = (\n              isMempoolAware ? data.boxes.filter(notBeingSpent) : data.boxes\n            ).map((b) => mapConfirmedBox(b, this.#biMapper));\n\n            boxes = boxes.concat(confirmedBoxes);\n          }\n\n          inclChain = data.boxes.length === pageSize;\n        }\n\n        if (isMempoolAware && hasMempool(data)) {\n          if (some(data.mempool.boxes)) {\n            const mempoolBoxes = data.mempool.boxes\n              .filter(notBeingSpent)\n              .map((b) => mapUnconfirmedBox(b, this.#biMapper));\n            boxes = boxes.concat(mempoolBoxes);\n          }\n\n          inclPool = data.mempool.boxes.length === pageSize;\n        }\n\n        if (some(boxes)) {\n          // boxes can be moved from the mempool to the blockchain while streaming,\n          // so we need to filter out boxes that have already been returned.\n          if (boxes.some((box) => returnedBoxIds.has(box.boxId))) {\n            boxes = boxes.filter((b) => !returnedBoxIds.has(b.boxId));\n          }\n\n          if (some(boxes)) {\n            boxes = uniqBy(boxes, (box) => box.boxId);\n            for (const box of boxes) returnedBoxIds.add(box.boxId);\n            yield boxes;\n          }\n        }\n\n        if (inclChain || inclPool) query.skip += pageSize;\n      }\n    }\n  }\n\n  async getBoxes(query: GraphQLBoxQuery): Promise<ChainProviderBox<I>[]> {\n    const boxes: ChainProviderBox<I>[][] = [];\n    for await (const chunk of this.streamBoxes(query)) boxes.push(chunk);\n    return orderBy(boxes.flat(), (box) => box.creationHeight);\n  }\n\n  async *streamUnconfirmedTransactions(\n    query: TransactionQuery<GraphQLUnconfirmedTransactionWhere> & SkipAndTake\n  ): AsyncGenerator<ChainProviderUnconfirmedTransaction<I>[]> {\n    const pageSize = query.take ?? PAGE_SIZE;\n    const queries = buildGqlUnconfirmedTxQueries(query);\n\n    for (const query of queries) {\n      let keepFetching = true;\n      while (keepFetching) {\n        const response = await this.#getUnconfirmedTransactions(query);\n        if (some(response.data?.mempool?.transactions)) {\n          yield response.data.mempool.transactions.map((t) =>\n            mapUnconfirmedTransaction(t, this.#biMapper)\n          );\n        }\n\n        keepFetching = response.data?.mempool?.transactions?.length === pageSize;\n        if (keepFetching) query.skip += pageSize;\n      }\n    }\n  }\n\n  async getUnconfirmedTransactions(\n    query: TransactionQuery<GraphQLUnconfirmedTransactionWhere>\n  ): Promise<ChainProviderUnconfirmedTransaction<I>[]> {\n    const transactions: ChainProviderUnconfirmedTransaction<I>[][] = [];\n    for await (const chunk of this.streamUnconfirmedTransactions(query)) {\n      transactions.push(chunk);\n    }\n\n    return transactions.flat();\n  }\n\n  async *streamConfirmedTransactions(\n    query: TransactionQuery<GraphQLConfirmedTransactionWhere> & SkipAndTake\n  ): AsyncGenerator<ChainProviderConfirmedTransaction<I>[]> {\n    const pageSize = query.take ?? PAGE_SIZE;\n    const queries = buildGqlConfirmedTxQueries(query);\n\n    for (const query of queries) {\n      let keepFetching = true;\n      while (keepFetching) {\n        const response = await this.#getConfirmedTransactions(query);\n        if (some(response.data?.transactions)) {\n          yield response.data.transactions.map((t) =>\n            mapConfirmedTransaction(t, this.#biMapper)\n          );\n        }\n\n        keepFetching = response.data?.transactions?.length === pageSize;\n        if (keepFetching) query.skip += pageSize;\n      }\n    }\n  }\n\n  async getConfirmedTransactions(\n    query: TransactionQuery<GraphQLConfirmedTransactionWhere>\n  ): Promise<ChainProviderConfirmedTransaction<I>[]> {\n    const transactions: ChainProviderConfirmedTransaction<I>[][] = [];\n    for await (const chunk of this.streamConfirmedTransactions(query)) {\n      transactions.push(chunk);\n    }\n\n    return transactions.flat();\n  }\n\n  async getHeaders(query: HeaderQuery): Promise<BlockHeader[]> {\n    const response = await this.#getHeaders(query);\n\n    return (\n      response.data?.blockHeaders.map((h) => ({\n        ...h,\n        id: h.headerId,\n        timestamp: Number(h.timestamp),\n        nBits: Number(h.nBits),\n        votes: hex.encode(Uint8Array.from(h.votes))\n      })) ?? []\n    );\n  }\n\n  createOperation<R, V extends GraphQLVariables = GraphQLVariables>(\n    query: string,\n    options?: Partial<ErgoGraphQLRequestOptions>\n  ): GraphQLOperation<GraphQLSuccessResponse<R>, V> {\n    const opt = ensureDefaults(options, this.#options);\n    opt.throwOnNonNetworkErrors = true;\n\n    return createGqlOperation(query, opt);\n  }\n\n  async checkTransaction(\n    signedTransaction: SignedTransaction\n  ): Promise<TransactionEvaluationResult> {\n    try {\n      const response = await this.#checkTransaction({ signedTransaction });\n      return { success: true, transactionId: response.data.checkTransaction };\n    } catch (e) {\n      return { success: false, message: (e as Error).message };\n    }\n  }\n\n  async submitTransaction(\n    signedTransaction: SignedTransaction\n  ): Promise<TransactionEvaluationResult> {\n    try {\n      const response = await this.#sendTransaction({ signedTransaction });\n      return { success: true, transactionId: response.data.submitTransaction };\n    } catch (e) {\n      return { success: false, message: (e as Error).message };\n    }\n  }\n\n  reduceTransaction(): Promise<TransactionReductionResult> {\n    throw new NotSupportedError(\"Transaction reducing is not supported by ergo-graphql.\");\n  }\n}\n\nfunction buildGqlBoxQueries(query: GraphQLBoxQuery & SkipAndTake) {\n  const ergoTrees = uniq(\n    [\n      merge(query.where.ergoTrees, query.where.ergoTree) ?? [],\n      merge(query.where.addresses, query.where.address)?.map((a) =>\n        typeof a === \"string\" ? ErgoAddress.decode(a).ergoTree : a.ergoTree\n      ) ?? []\n    ].flat()\n  );\n\n  return chunk(ergoTrees, MAX_ARGS).map((chunk) => ({\n    spent: false,\n    boxIds: query.where.boxId ? [query.where.boxId] : undefined,\n    ergoTrees: chunk,\n    ergoTreeTemplateHash: query.where.templateHash,\n    tokenId: query.where.tokenId,\n    skip: query.skip ?? 0,\n    take: query.take ?? PAGE_SIZE\n  }));\n}\n\nfunction buildGqlUnconfirmedTxQueries(\n  query: TransactionQuery<GraphQLUnconfirmedTransactionWhere> & SkipAndTake\n) {\n  const addresses = uniq(\n    [\n      merge(query.where.addresses, query.where.address)?.map((address): string =>\n        typeof address === \"string\" ? address : address.encode()\n      ) ?? [],\n      merge(query.where.ergoTrees, query.where.ergoTree)?.map((tree) =>\n        ErgoAddress.fromErgoTree(tree).encode()\n      ) ?? []\n    ].flat()\n  );\n\n  return chunk(addresses, MAX_ARGS).map((chunk) => ({\n    addresses: chunk.length ? chunk : undefined,\n    transactionIds: query.where.transactionId ? [query.where.transactionId] : undefined,\n    skip: query.skip ?? 0,\n    take: query.take ?? PAGE_SIZE\n  }));\n}\n\nfunction buildGqlConfirmedTxQueries(\n  query: TransactionQuery<GraphQLConfirmedTransactionWhere> & SkipAndTake\n) {\n  return buildGqlUnconfirmedTxQueries(\n    query as TransactionQuery<GraphQLUnconfirmedTransactionWhere>\n  ).map((q) => ({\n    ...q,\n    headerId: query.where.headerId,\n    minHeight: query.where.minHeight,\n    onlyRelevantOutputs: query.where.onlyRelevantOutputs\n  }));\n}\n\nfunction merge<T>(array?: T[], el?: T) {\n  if (isEmpty(array) && isUndefined(el)) return;\n\n  const set = new Set<T>(array ?? []);\n  if (!isUndefined(el)) set.add(el);\n  return Array.from(set.values());\n}\n\nfunction hasMempool(data: unknown): data is UnconfirmedBoxesResponse {\n  return !!(data as UnconfirmedBoxesResponse)?.mempool?.boxes;\n}\n\nfunction hasConfirmed(data: unknown): data is ConfirmedBoxesResponse {\n  return !!(data as ConfirmedBoxesResponse)?.boxes;\n}\n\nfunction mapConfirmedBox<T>(box: GQLBox, mapper: BiMapper<T>): ChainProviderBox<T> {\n  const mapped = mapBox(box, mapper) as ChainProviderBox<T>;\n  mapped.confirmed = true;\n  return mapped;\n}\n\nfunction mapUnconfirmedBox<T>(box: GQLBox, mapper: BiMapper<T>): ChainProviderBox<T> {\n  const mapped = mapBox(box, mapper) as ChainProviderBox<T>;\n  mapped.confirmed = false;\n  return mapped;\n}\n\nfunction mapBox<T>(\n  box: GQLBox | GQLUnconfirmedBox,\n  mapper: BiMapper<T>\n): Omit<ChainProviderBox<T>, \"confirmed\"> {\n  return {\n    boxId: box.boxId,\n    transactionId: box.transactionId,\n    value: mapper(box.value),\n    ergoTree: box.ergoTree,\n    assets: box.assets.map((t) => ({ tokenId: t.tokenId, amount: mapper(t.amount) })),\n    creationHeight: box.creationHeight,\n    additionalRegisters: box.additionalRegisters,\n    index: box.index\n  };\n}\n\nfunction mapUnconfirmedTransaction<T>(\n  tx: UnconfirmedTransaction,\n  mapper: BiMapper<T>\n): ChainProviderUnconfirmedTransaction<T> {\n  return {\n    transactionId: tx.transactionId,\n    timestamp: Number(tx.timestamp),\n    inputs: tx.inputs.map((i) => ({\n      spendingProof: {\n        // biome-ignore lint/style/noNonNullAssertion: bad type declarations at '@ergo-graphql/type'\n        extension: i.extension!,\n        // biome-ignore lint/style/noNonNullAssertion: bad type declarations at '@ergo-graphql/type'\n        proofBytes: i.proofBytes!\n      },\n      // biome-ignore lint/style/noNonNullAssertion: bad type declarations at '@ergo-graphql/type'\n      ...mapBox(i.box!, mapper)\n    })),\n    dataInputs: tx.dataInputs.map((di) => ({ boxId: di.boxId })),\n    outputs: tx.outputs.map((b) => mapBox(b, mapper)),\n    confirmed: false\n  };\n}\n\nfunction mapConfirmedTransaction<T>(\n  tx: Transaction,\n  mapper: BiMapper<T>\n): ChainProviderConfirmedTransaction<T> {\n  return {\n    transactionId: tx.transactionId,\n    timestamp: Number(tx.timestamp),\n    inputs: tx.inputs.map((i) => ({\n      spendingProof: {\n        // biome-ignore lint/style/noNonNullAssertion: bad type declarations at '@ergo-graphql/type'\n        extension: i.extension!,\n        // biome-ignore lint/style/noNonNullAssertion: bad type declarations at '@ergo-graphql/type'\n        proofBytes: i.proofBytes!\n      },\n      // biome-ignore lint/style/noNonNullAssertion: bad type declarations at '@ergo-graphql/type'\n      ...mapBox(i.box!, mapper)\n    })),\n    dataInputs: tx.dataInputs.map((di) => ({ boxId: di.boxId })),\n    outputs: tx.outputs.map((b) => mapBox(b, mapper)),\n    height: tx.inclusionHeight,\n    headerId: tx.headerId,\n    index: tx.index,\n    confirmed: true\n  };\n}\n\nexport function isRequestParam(obj: unknown): obj is ErgoGraphQLRequestOptions {\n  return typeof obj === \"object\" && (obj as ErgoGraphQLRequestOptions).url !== undefined;\n}\n"]}