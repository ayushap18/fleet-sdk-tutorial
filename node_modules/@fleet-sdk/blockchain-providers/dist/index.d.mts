import { BoxId, HexString, Base58String, TokenId, TransactionId, Box, DataInput, BlockHeader, SignedTransaction, UnsignedTransaction, ProverResult } from '@fleet-sdk/common';
import { ErgoAddress } from '@fleet-sdk/core';

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

/**
Returns a boolean for whether the two given types are equal.

@link https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650
@link https://stackoverflow.com/questions/68961864/how-does-the-equals-work-in-typescript/68963796#68963796

Use-cases:
- If you want to make a conditional branch based on the result of a comparison of two types.

@example
```
import type {IsEqual} from 'type-fest';

// This type returns a boolean for whether the given array includes the given item.
// `IsEqual` is used to compare the given array at position 0 and the given item and then return true if they are equal.
type Includes<Value extends readonly any[], Item> =
	Value extends readonly [Value[0], ...infer rest]
		? IsEqual<Value[0], Item> extends true
			? true
			: Includes<rest, Item>
		: false;
```

@category Type Guard
@category Utilities
*/
type IsEqual<A, B> =
	(<G>() => G extends A ? 1 : 2) extends
	(<G>() => G extends B ? 1 : 2)
		? true
		: false;

/**
Filter out keys from an object.

Returns `never` if `Exclude` is strictly equal to `Key`.
Returns `never` if `Key` extends `Exclude`.
Returns `Key` otherwise.

@example
```
type Filtered = Filter<'foo', 'foo'>;
//=> never
```

@example
```
type Filtered = Filter<'bar', string>;
//=> never
```

@example
```
type Filtered = Filter<'bar', 'foo'>;
//=> 'bar'
```

@see {Except}
*/
type Filter<KeyType, ExcludeType> = IsEqual<KeyType, ExcludeType> extends true ? never : (KeyType extends ExcludeType ? never : KeyType);

type ExceptOptions = {
	/**
	Disallow assigning non-specified properties.

	Note that any omitted properties in the resulting type will be present in autocomplete as `undefined`.

	@default false
	*/
	requireExactProps?: boolean;
};

/**
Create a type from an object type without certain keys.

We recommend setting the `requireExactProps` option to `true`.

This type is a stricter version of [`Omit`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type). The `Omit` type does not restrict the omitted keys to be keys present on the given type, while `Except` does. The benefits of a stricter type are avoiding typos and allowing the compiler to pick up on rename refactors automatically.

This type was proposed to the TypeScript team, which declined it, saying they prefer that libraries implement stricter versions of the built-in types ([microsoft/TypeScript#30825](https://github.com/microsoft/TypeScript/issues/30825#issuecomment-523668235)).

@example
```
import type {Except} from 'type-fest';

type Foo = {
	a: number;
	b: string;
};

type FooWithoutA = Except<Foo, 'a'>;
//=> {b: string}

const fooWithoutA: FooWithoutA = {a: 1, b: '2'};
//=> errors: 'a' does not exist in type '{ b: string; }'

type FooWithoutB = Except<Foo, 'b', {requireExactProps: true}>;
//=> {a: number} & Partial<Record<"b", never>>

const fooWithoutB: FooWithoutB = {a: 1, b: '2'};
//=> errors at 'b': Type 'string' is not assignable to type 'undefined'.
```

@category Object
*/
type Except<ObjectType, KeysType extends keyof ObjectType, Options extends ExceptOptions = {requireExactProps: false}> = {
	[KeyType in keyof ObjectType as Filter<KeyType, KeysType>]: ObjectType[KeyType];
} & (Options['requireExactProps'] extends true
	? Partial<Record<KeysType, never>>
	: {});

/**
Create a type that requires at least one of the given keys. The remaining keys are kept as is.

@example
```
import type {RequireAtLeastOne} from 'type-fest';

type Responder = {
	text?: () => string;
	json?: () => string;
	secure?: boolean;
};

const responder: RequireAtLeastOne<Responder, 'text' | 'json'> = {
	json: () => '{"message": "ok"}',
	secure: true
};
```

@category Object
*/
type RequireAtLeastOne<
	ObjectType,
	KeysType extends keyof ObjectType = keyof ObjectType,
> = {
	// For each `Key` in `KeysType` make a mapped type:
	[Key in KeysType]-?: Required<Pick<ObjectType, Key>> & // 1. Make `Key`'s type required
	// 2. Make all other keys in `KeysType` optional
	Partial<Pick<ObjectType, Exclude<KeysType, Key>>>;
}[KeysType] &
// 3. Add the remaining keys not in `KeysType`
Except<ObjectType, KeysType>;

type BoxSource = "blockchain" | "mempool" | "blockchain+mempool";
type BoxWhere = {
    /** Base16-encoded BoxId */
    boxId?: BoxId;
    /** Base16-encoded ErgoTree */
    ergoTree?: HexString;
    /** Base58-encoded address */
    address?: ErgoAddress | Base58String;
    /** Base16-encoded contract template hash */
    templateHash?: HexString;
    /**  Base16-encoded TokenId */
    tokenId?: TokenId;
};
type BoxQuery<W extends BoxWhere> = {
    /** The query to filter boxes. */
    where: RequireAtLeastOne<W>;
    /**
     * The source of boxes to query.
     * @default "blockchain+mempool"
     */
    from?: BoxSource;
};
type UnconfirmedTransactionWhere = {
    /** Base16-encoded TransactionId */
    transactionId?: TransactionId;
    /** Base58-encoded address */
    address?: ErgoAddress | Base58String;
    /** Base16-encoded ErgoTree */
    ergoTree?: HexString;
};
type ConfirmedTransactionWhere = {
    /** Base16-encoded TransactionId */
    transactionId?: TransactionId;
    /** Base16-encoded HeaderID */
    headerId?: HexString;
    /** Base58-encoded address */
    address?: ErgoAddress | Base58String;
    /** Base16-encoded ErgoTree */
    ergoTree?: HexString;
    /** Min blockchain height */
    minHeight?: number;
    /** Only returns relevant outputs for the selected filter params */
    onlyRelevantOutputs?: boolean;
};
type TransactionQuery<W extends ConfirmedTransactionWhere> = {
    /** The query to filter boxes. */
    where: RequireAtLeastOne<W, keyof Omit<W, "minHeight" | "onlyRelevantOutputs">>;
};
type HeaderQuery = {
    take: number;
};
type ChainProviderBox<T> = Omit<Box, "value" | "assets"> & {
    value: T;
    assets: {
        tokenId: TokenId;
        amount: T;
    }[];
    confirmed: boolean;
};
type TransactionOutput<T> = Omit<ChainProviderBox<T>, "confirmed">;
type TransactionInput<T> = TransactionOutput<T> & {
    spendingProof: ProverResult;
};
type ChainProviderUnconfirmedTransaction<T> = {
    transactionId: TransactionId;
    inputs: TransactionInput<T>[];
    dataInputs: DataInput[];
    outputs: TransactionOutput<T>[];
    confirmed: boolean;
    timestamp: number;
};
type ChainProviderConfirmedTransaction<T> = ChainProviderUnconfirmedTransaction<T> & {
    height: number;
    index: number;
    headerId: HexString;
};
type TransactionEvaluationError = {
    success: false;
    message: string;
};
type TransactionEvaluationSuccess = {
    success: true;
    transactionId: TransactionId;
};
type TransactionReductionSuccess = {
    success: true;
    reducedTransaction: HexString;
};
type TransactionEvaluationResult = TransactionEvaluationError | TransactionEvaluationSuccess;
type TransactionReductionResult = TransactionEvaluationError | TransactionReductionSuccess;
/**
 * Represents a blockchain provider that can interact with the blockchain.
 * @template B The type of the box query used by the provider.
 */
interface IBlockchainProvider<I> {
    /**
     * Get boxes.
     */
    getBoxes(query: BoxQuery<BoxWhere>): Promise<ChainProviderBox<I>[]>;
    /**
     * Stream boxes.
     */
    streamBoxes(query: BoxQuery<BoxWhere>): AsyncGenerator<ChainProviderBox<I>[]>;
    /**
     * Stream unconfirmed transactions
     */
    streamUnconfirmedTransactions(query: TransactionQuery<UnconfirmedTransactionWhere>): AsyncGenerator<ChainProviderUnconfirmedTransaction<I>[]>;
    /**
     * Get unconfirmed transactions
     */
    getUnconfirmedTransactions(query: TransactionQuery<UnconfirmedTransactionWhere>): Promise<ChainProviderUnconfirmedTransaction<I>[]>;
    /**
     * Stream confirmed transactions
     */
    streamConfirmedTransactions(query: TransactionQuery<ConfirmedTransactionWhere>): AsyncGenerator<ChainProviderConfirmedTransaction<I>[]>;
    /**
     * Get confirmed transactions
     */
    getConfirmedTransactions(query: TransactionQuery<ConfirmedTransactionWhere>): Promise<ChainProviderConfirmedTransaction<I>[]>;
    /**
     * Get headers.
     */
    getHeaders(query: HeaderQuery): Promise<BlockHeader[]>;
    /**
     * Check for transaction validity without broadcasting it to the network.
     */
    checkTransaction(transaction: SignedTransaction): Promise<TransactionEvaluationResult>;
    /**
     * Broadcast a transaction to the network.
     */
    submitTransaction(transaction: SignedTransaction): Promise<TransactionEvaluationResult>;
    /**
     * Evaluate a transaction and return Base16-encoded evaluation result.
     */
    reduceTransaction(transaction: UnsignedTransaction): Promise<TransactionReductionResult>;
}

interface ParserLike {
    parse<T>(text: string): T;
    stringify<T>(value: T): string;
}
type Route = {
    base: string;
    path: string;
    query?: Record<string, unknown>;
};
type URLLike = string | Route;
type FallbackRetryOptions = {
    fallbacks?: URLLike[];
} & RetryOptions;
type FetchOptions = {
    parser?: ParserLike;
    base?: string;
    query?: Record<string, unknown>;
    retry?: FallbackRetryOptions;
    httpOptions?: RequestInit;
};
declare function request<T>(path: string, opt?: Partial<FetchOptions>): Promise<T>;
type RetryOptions = {
    attempts: number;
    delay: number;
};
/**
 * Retries an asynchronous operation a specified number of times with a delay
 * growing exponentially between each attempt.
 * @param operation - The asynchronous operation to retry.
 * @param options - The retry options.
 * @returns A promise that resolves to the result of the operation, or undefined
 * if all attempts fail.
 */
declare function exponentialRetry<T>(operation: (remainingAttempts: number) => Promise<T>, { attempts, delay }: RetryOptions): Promise<T>;

type GraphQLVariables = Record<string, unknown> | null;
interface GraphQLError {
    message: string;
}
interface GraphQLSuccessResponse<T = unknown> {
    data: T;
    errors: null;
}
interface GraphQLErrorResponse {
    data: null;
    errors: GraphQLError[];
}
type GraphQLResponse<T = unknown> = GraphQLSuccessResponse<T> | GraphQLErrorResponse;
type GraphQLOperation<R extends GraphQLResponse, V extends GraphQLVariables> = (variables?: V, url?: string) => Promise<R>;
type GraphQLRequiredUrlOperation<R extends GraphQLResponse, V extends GraphQLVariables> = (variables: V | undefined, url: string) => Promise<R>;
interface GraphQLRequestOptions {
    url?: string;
    parser?: ParserLike;
    retry?: FallbackRetryOptions;
    throwOnNonNetworkErrors?: boolean;
    httpOptions?: Omit<RequestInit, "body" | "method">;
}
declare function createGqlOperation<R, V extends GraphQLVariables = GraphQLVariables>(query: string, options: GraphQLRequestOptions & {
    throwOnNonNetworkErrors: true;
}): GraphQLOperation<GraphQLSuccessResponse<R>, V>;
declare function createGqlOperation<R, V extends GraphQLVariables = GraphQLVariables>(query: string, options?: GraphQLRequestOptions & {
    url: undefined;
}): GraphQLRequiredUrlOperation<GraphQLResponse<R>, V>;
declare function createGqlOperation<R, V extends GraphQLVariables = GraphQLVariables>(query: string, options: GraphQLRequestOptions & {
    url: undefined;
    throwOnNonNetworkErrors: true;
}): GraphQLRequiredUrlOperation<GraphQLSuccessResponse<R>, V>;
declare function createGqlOperation<R, V extends GraphQLVariables = GraphQLVariables>(query: string, options: GraphQLRequestOptions): GraphQLOperation<GraphQLResponse<R>, V>;
declare function gql(query: TemplateStringsArray): string;
declare function getOpName(query: string): string | undefined;

type SkipAndTake = {
    skip?: number;
    take?: number;
};
type GraphQLBoxWhere = BoxWhere & {
    /** Base16-encoded ErgoTrees */
    ergoTrees?: HexString[];
    /** Base58-encoded addresses or `ErgoAddress` objects */
    addresses?: (Base58String | ErgoAddress)[];
};
type GraphQLConfirmedTransactionWhere = ConfirmedTransactionWhere & {
    addresses?: (Base58String | ErgoAddress)[];
    ergoTrees?: HexString[];
};
type GraphQLUnconfirmedTransactionWhere = UnconfirmedTransactionWhere & {
    addresses?: (Base58String | ErgoAddress)[];
    ergoTrees?: HexString[];
};
type GraphQLBoxQuery = BoxQuery<GraphQLBoxWhere>;
type ErgoGraphQLRequestOptions = Omit<GraphQLRequestOptions, "throwOnNonNetworkErrors">;
type BiMapper<T> = (value: string) => T;
declare class ErgoGraphQLProvider<I = bigint> implements IBlockchainProvider<I> {
    #private;
    constructor(url: string);
    constructor(options: ErgoGraphQLRequestOptions);
    setUrl(url: string): ErgoGraphQLProvider<I>;
    setBigIntMapper<M>(mapper: BiMapper<M>): ErgoGraphQLProvider<M>;
    streamBoxes(query: GraphQLBoxQuery & SkipAndTake): AsyncGenerator<ChainProviderBox<I>[]>;
    getBoxes(query: GraphQLBoxQuery): Promise<ChainProviderBox<I>[]>;
    streamUnconfirmedTransactions(query: TransactionQuery<GraphQLUnconfirmedTransactionWhere> & SkipAndTake): AsyncGenerator<ChainProviderUnconfirmedTransaction<I>[]>;
    getUnconfirmedTransactions(query: TransactionQuery<GraphQLUnconfirmedTransactionWhere>): Promise<ChainProviderUnconfirmedTransaction<I>[]>;
    streamConfirmedTransactions(query: TransactionQuery<GraphQLConfirmedTransactionWhere> & SkipAndTake): AsyncGenerator<ChainProviderConfirmedTransaction<I>[]>;
    getConfirmedTransactions(query: TransactionQuery<GraphQLConfirmedTransactionWhere>): Promise<ChainProviderConfirmedTransaction<I>[]>;
    getHeaders(query: HeaderQuery): Promise<BlockHeader[]>;
    createOperation<R, V extends GraphQLVariables = GraphQLVariables>(query: string, options?: Partial<ErgoGraphQLRequestOptions>): GraphQLOperation<GraphQLSuccessResponse<R>, V>;
    checkTransaction(signedTransaction: SignedTransaction): Promise<TransactionEvaluationResult>;
    submitTransaction(signedTransaction: SignedTransaction): Promise<TransactionEvaluationResult>;
    reduceTransaction(): Promise<TransactionReductionResult>;
}
declare function isRequestParam(obj: unknown): obj is ErgoGraphQLRequestOptions;

export { type BoxQuery, type BoxSource, type BoxWhere, type ChainProviderBox, type ChainProviderConfirmedTransaction, type ChainProviderUnconfirmedTransaction, type ConfirmedTransactionWhere, ErgoGraphQLProvider, type ErgoGraphQLRequestOptions, type FallbackRetryOptions, type FetchOptions, type GraphQLBoxQuery, type GraphQLBoxWhere, type GraphQLConfirmedTransactionWhere, type GraphQLError, type GraphQLErrorResponse, type GraphQLOperation, type GraphQLRequestOptions, type GraphQLRequiredUrlOperation, type GraphQLResponse, type GraphQLSuccessResponse, type GraphQLUnconfirmedTransactionWhere, type GraphQLVariables, type HeaderQuery, type IBlockchainProvider, type ParserLike, type RetryOptions, type Route, type TransactionEvaluationError, type TransactionEvaluationResult, type TransactionEvaluationSuccess, type TransactionQuery, type TransactionReductionResult, type TransactionReductionSuccess, type URLLike, type UnconfirmedTransactionWhere, createGqlOperation, exponentialRetry, getOpName, gql, isRequestParam, request };
