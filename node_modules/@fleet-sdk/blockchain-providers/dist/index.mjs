import { some, ensureDefaults, clearUndefined, isEmpty, BlockchainProviderError, uniqBy, orderBy, NotSupportedError, uniq, chunk, isUndefined, assertInstanceOf, assertTypeOf, assert } from '@fleet-sdk/common';
import { ErgoAddress } from '@fleet-sdk/core';

// src/ergo-graphql/ergoGraphQLProvider.ts
new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
var HEXES = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
var HexChar = {
  ZERO: 48,
  // 0
  NINE: 57,
  // 9
  A_UP: 65,
  // A
  F_UP: 70,
  // F
  A_LO: 97,
  // a
  F_LO: 102
  // f
};
function bytesToHex(bytes2) {
  assertInstanceOf(bytes2, Uint8Array);
  let hex3 = "";
  for (let i = 0, len = bytes2.length; i < len; i++) {
    hex3 += HEXES[bytes2[i]];
  }
  return hex3;
}
function hexToBytes(hex3) {
  assertTypeOf(hex3, "string");
  assert(hex3.length % 2 === 0, "Invalid hex padding.");
  const len = hex3.length / 2;
  const bytes2 = new Uint8Array(len);
  for (let i = 0, j = 0; i < len; i++) {
    const n1 = charCodeToBase16(hex3.charCodeAt(j++));
    const n2 = charCodeToBase16(hex3.charCodeAt(j++));
    bytes2[i] = n1 * 16 + n2;
  }
  return bytes2;
}
function charCodeToBase16(char) {
  if (char >= HexChar.ZERO && char <= HexChar.NINE) return char - HexChar.ZERO;
  if (char >= HexChar.A_UP && char <= HexChar.F_UP) return char - (HexChar.A_UP - 10);
  if (char >= HexChar.A_LO && char <= HexChar.F_LO) return char - (HexChar.A_LO - 10);
  throw new Error("Invalid byte sequence.");
}
var hex2 = {
  encode: bytesToHex,
  decode: hexToBytes
};
var RETRY_STATUS_CODES = /* @__PURE__ */ new Set([
  408,
  // Request Timeout
  409,
  // Conflict
  425,
  // Too Early (Experimental)
  429,
  // Too Many Requests
  500,
  // Internal Server Error
  502,
  // Bad Gateway
  503,
  // Service Unavailable
  504
  // Gateway Timeout
]);
async function request(path, opt) {
  const url = buildURL(path, opt?.query, opt?.base);
  let response;
  if (opt?.retry) {
    const routes = some(opt.retry.fallbacks) ? [url, ...opt.retry.fallbacks] : [url];
    const attempts = opt.retry.attempts;
    response = await exponentialRetry(async (r) => {
      const response2 = await fetch(resolveUrl(routes, attempts - r), opt.httpOptions);
      if (RETRY_STATUS_CODES.has(response2.status)) throw new Error(response2.statusText);
      return response2;
    }, opt.retry);
  } else {
    response = await fetch(url, opt?.httpOptions);
  }
  return (opt?.parser || JSON).parse(await response.text());
}
function resolveUrl(routes, attempt) {
  const route = routes[attempt % routes.length];
  return typeof route === "string" ? route : buildURL(route.path, route.query, route.base).toString();
}
function buildURL(path, query, base) {
  if (!base && !query) return path;
  const url = new URL(path, base);
  if (some(query)) {
    for (const key in query) url.searchParams.append(key, String(query[key]));
  }
  return url.toString();
}
async function exponentialRetry(operation, { attempts, delay }) {
  try {
    return await operation(attempts);
  } catch (e) {
    if (attempts > 0) {
      await new Promise((resolve) => setTimeout(resolve, delay));
      return exponentialRetry(operation, { attempts: attempts - 1, delay: delay * 2 });
    }
    throw e;
  }
}

// src/utils/graphql.ts
var OP_NAME_REGEX = /(query|mutation)\s?([\w\-_]+)?/;
var DEFAULT_HEADERS = {
  "content-type": "application/json; charset=utf-8",
  accept: "application/graphql-response+json, application/json"
};
function createGqlOperation(query, options) {
  return async (variables, url) => {
    url = url ?? options?.url;
    if (!url) throw new Error("URL is required");
    const response = await request(url, {
      ...options,
      httpOptions: {
        ...options?.httpOptions,
        method: "POST",
        headers: ensureDefaults(options?.httpOptions?.headers, DEFAULT_HEADERS),
        body: (options?.parser ?? JSON).stringify({
          operationName: getOpName(query),
          query,
          variables: variables ? clearUndefined(variables) : void 0
        })
      }
    });
    if (options?.throwOnNonNetworkErrors && some(response.errors) && isEmpty(response.data)) {
      const msg = response.errors[0].message;
      throw new BlockchainProviderError(msg, { cause: response.errors });
    }
    return response;
  };
}
function gql(query) {
  return query[0];
}
function getOpName(query) {
  return OP_NAME_REGEX.exec(query)?.at(2);
}

// src/ergo-graphql/queries.ts
var B = [
  "$boxIds: [String!] $ergoTrees: [String!] $ergoTreeTemplateHash: String $tokenId: String $skip: Int $take: Int",
  "boxIds: $boxIds ergoTrees: $ergoTrees ergoTreeTemplateHash: $ergoTreeTemplateHash tokenId: $tokenId skip: $skip take: $take",
  "boxId transactionId index value creationHeight ergoTree assets { tokenId amount } additionalRegisters"
];
var CONF_BOXES_QUERY = `query boxes($spent: Boolean! ${B[0]}) { boxes(spent: $spent ${B[1]}) { ${B[2]} beingSpent } }`;
var UNCONF_BOXES_QUERY = `query boxes(${B[0]}) { mempool { boxes(${B[1]}) { ${B[2]} beingSpent } } }`;
var ALL_BOXES_QUERY = `query boxes($spent: Boolean! ${B[0]}) { boxes(spent: $spent ${B[1]}) { ${B[2]} beingSpent } mempool { boxes(${B[1]}) { ${B[2]} beingSpent } } }`;
var HEADERS_QUERY = "query blockHeaders($take: Int) { blockHeaders(take: $take) {headerId timestamp version adProofsRoot stateRoot transactionsRoot nBits extensionHash powSolutions height difficulty parentId votes } }";
var CHECK_TX_MUTATION = "mutation checkTransaction($signedTransaction: SignedTransaction!) { checkTransaction(signedTransaction: $signedTransaction) }";
var SEND_TX_MUTATION = "mutation submitTransaction($signedTransaction: SignedTransaction!) { submitTransaction(signedTransaction: $signedTransaction) }";
var T = [
  "$addresses: [String!], $transactionIds: [String!], $skip: Int, $take: Int",
  "addresses: $addresses, transactionIds: $transactionIds, skip: $skip, take: $take",
  `transactionId timestamp inputs { proofBytes extension index box { ${B[2]} } } dataInputs { boxId }`
];
var CONF_TX_QUERY = `query confirmedTransactions(${T[0]}  $onlyRelevantOutputs: Boolean) { transactions(${T[1]}) { ${T[2]} outputs(relevantOnly: $onlyRelevantOutputs) { ${B[2]} } inclusionHeight headerId index } }`;
var UNCONF_TX_QUERY = `query unconfirmedTransactions(${T[0]}) { mempool { transactions(${T[1]}) { ${T[2]} outputs { ${B[2]} } } } }`;

// src/ergo-graphql/ergoGraphQLProvider.ts
var PAGE_SIZE = 50;
var MAX_ARGS = 20;
var ErgoGraphQLProvider = class {
  #options;
  #biMapper;
  #getConfirmedBoxes;
  #getUnconfirmedBoxes;
  #getAllBoxes;
  #getConfirmedTransactions;
  #getUnconfirmedTransactions;
  #checkTransaction;
  #sendTransaction;
  #getHeaders;
  constructor(optOrUrl) {
    this.#biMapper = (value) => BigInt(value);
    this.#options = {
      ...isRequestParam(optOrUrl) ? optOrUrl : { url: optOrUrl },
      throwOnNonNetworkErrors: true
    };
    this.#getConfirmedBoxes = this.createOperation(CONF_BOXES_QUERY);
    this.#getUnconfirmedBoxes = this.createOperation(UNCONF_BOXES_QUERY);
    this.#getAllBoxes = this.createOperation(ALL_BOXES_QUERY);
    this.#getConfirmedTransactions = this.createOperation(CONF_TX_QUERY);
    this.#getUnconfirmedTransactions = this.createOperation(UNCONF_TX_QUERY);
    this.#checkTransaction = this.createOperation(CHECK_TX_MUTATION);
    this.#sendTransaction = this.createOperation(SEND_TX_MUTATION);
    this.#getHeaders = this.createOperation(HEADERS_QUERY);
  }
  #fetchBoxes(args, inclConf, inclUnconf) {
    return inclConf && inclUnconf ? this.#getAllBoxes(args) : inclUnconf ? this.#getUnconfirmedBoxes(args) : this.#getConfirmedBoxes(args);
  }
  setUrl(url) {
    this.#options.url = url;
    return this;
  }
  setBigIntMapper(mapper) {
    this.#biMapper = mapper;
    return this;
  }
  async *streamBoxes(query) {
    if (isEmpty(query.where)) {
      throw new Error("Cannot fetch unspent boxes without a where clause.");
    }
    const notBeingSpent = (box) => !box.beingSpent;
    const returnedBoxIds = /* @__PURE__ */ new Set();
    const { from, take } = query;
    const pageSize = take ?? PAGE_SIZE;
    const queries = buildGqlBoxQueries(query);
    const isMempoolAware = from !== "blockchain";
    for (const query2 of queries) {
      let inclChain = from !== "mempool";
      let inclPool = from !== "blockchain";
      while (inclChain || inclPool) {
        const { data } = await this.#fetchBoxes(query2, inclChain, inclPool);
        let boxes = [];
        if (inclChain && hasConfirmed(data)) {
          if (some(data.boxes)) {
            const confirmedBoxes = (isMempoolAware ? data.boxes.filter(notBeingSpent) : data.boxes).map((b) => mapConfirmedBox(b, this.#biMapper));
            boxes = boxes.concat(confirmedBoxes);
          }
          inclChain = data.boxes.length === pageSize;
        }
        if (isMempoolAware && hasMempool(data)) {
          if (some(data.mempool.boxes)) {
            const mempoolBoxes = data.mempool.boxes.filter(notBeingSpent).map((b) => mapUnconfirmedBox(b, this.#biMapper));
            boxes = boxes.concat(mempoolBoxes);
          }
          inclPool = data.mempool.boxes.length === pageSize;
        }
        if (some(boxes)) {
          if (boxes.some((box) => returnedBoxIds.has(box.boxId))) {
            boxes = boxes.filter((b) => !returnedBoxIds.has(b.boxId));
          }
          if (some(boxes)) {
            boxes = uniqBy(boxes, (box) => box.boxId);
            for (const box of boxes) returnedBoxIds.add(box.boxId);
            yield boxes;
          }
        }
        if (inclChain || inclPool) query2.skip += pageSize;
      }
    }
  }
  async getBoxes(query) {
    const boxes = [];
    for await (const chunk2 of this.streamBoxes(query)) boxes.push(chunk2);
    return orderBy(boxes.flat(), (box) => box.creationHeight);
  }
  async *streamUnconfirmedTransactions(query) {
    const pageSize = query.take ?? PAGE_SIZE;
    const queries = buildGqlUnconfirmedTxQueries(query);
    for (const query2 of queries) {
      let keepFetching = true;
      while (keepFetching) {
        const response = await this.#getUnconfirmedTransactions(query2);
        if (some(response.data?.mempool?.transactions)) {
          yield response.data.mempool.transactions.map(
            (t) => mapUnconfirmedTransaction(t, this.#biMapper)
          );
        }
        keepFetching = response.data?.mempool?.transactions?.length === pageSize;
        if (keepFetching) query2.skip += pageSize;
      }
    }
  }
  async getUnconfirmedTransactions(query) {
    const transactions = [];
    for await (const chunk2 of this.streamUnconfirmedTransactions(query)) {
      transactions.push(chunk2);
    }
    return transactions.flat();
  }
  async *streamConfirmedTransactions(query) {
    const pageSize = query.take ?? PAGE_SIZE;
    const queries = buildGqlConfirmedTxQueries(query);
    for (const query2 of queries) {
      let keepFetching = true;
      while (keepFetching) {
        const response = await this.#getConfirmedTransactions(query2);
        if (some(response.data?.transactions)) {
          yield response.data.transactions.map(
            (t) => mapConfirmedTransaction(t, this.#biMapper)
          );
        }
        keepFetching = response.data?.transactions?.length === pageSize;
        if (keepFetching) query2.skip += pageSize;
      }
    }
  }
  async getConfirmedTransactions(query) {
    const transactions = [];
    for await (const chunk2 of this.streamConfirmedTransactions(query)) {
      transactions.push(chunk2);
    }
    return transactions.flat();
  }
  async getHeaders(query) {
    const response = await this.#getHeaders(query);
    return response.data?.blockHeaders.map((h) => ({
      ...h,
      id: h.headerId,
      timestamp: Number(h.timestamp),
      nBits: Number(h.nBits),
      votes: hex2.encode(Uint8Array.from(h.votes))
    })) ?? [];
  }
  createOperation(query, options) {
    const opt = ensureDefaults(options, this.#options);
    opt.throwOnNonNetworkErrors = true;
    return createGqlOperation(query, opt);
  }
  async checkTransaction(signedTransaction) {
    try {
      const response = await this.#checkTransaction({ signedTransaction });
      return { success: true, transactionId: response.data.checkTransaction };
    } catch (e) {
      return { success: false, message: e.message };
    }
  }
  async submitTransaction(signedTransaction) {
    try {
      const response = await this.#sendTransaction({ signedTransaction });
      return { success: true, transactionId: response.data.submitTransaction };
    } catch (e) {
      return { success: false, message: e.message };
    }
  }
  reduceTransaction() {
    throw new NotSupportedError("Transaction reducing is not supported by ergo-graphql.");
  }
};
function buildGqlBoxQueries(query) {
  const ergoTrees = uniq(
    [
      merge(query.where.ergoTrees, query.where.ergoTree) ?? [],
      merge(query.where.addresses, query.where.address)?.map(
        (a) => typeof a === "string" ? ErgoAddress.decode(a).ergoTree : a.ergoTree
      ) ?? []
    ].flat()
  );
  return chunk(ergoTrees, MAX_ARGS).map((chunk2) => ({
    spent: false,
    boxIds: query.where.boxId ? [query.where.boxId] : void 0,
    ergoTrees: chunk2,
    ergoTreeTemplateHash: query.where.templateHash,
    tokenId: query.where.tokenId,
    skip: query.skip ?? 0,
    take: query.take ?? PAGE_SIZE
  }));
}
function buildGqlUnconfirmedTxQueries(query) {
  const addresses = uniq(
    [
      merge(query.where.addresses, query.where.address)?.map(
        (address) => typeof address === "string" ? address : address.encode()
      ) ?? [],
      merge(query.where.ergoTrees, query.where.ergoTree)?.map(
        (tree) => ErgoAddress.fromErgoTree(tree).encode()
      ) ?? []
    ].flat()
  );
  return chunk(addresses, MAX_ARGS).map((chunk2) => ({
    addresses: chunk2.length ? chunk2 : void 0,
    transactionIds: query.where.transactionId ? [query.where.transactionId] : void 0,
    skip: query.skip ?? 0,
    take: query.take ?? PAGE_SIZE
  }));
}
function buildGqlConfirmedTxQueries(query) {
  return buildGqlUnconfirmedTxQueries(
    query
  ).map((q) => ({
    ...q,
    headerId: query.where.headerId,
    minHeight: query.where.minHeight,
    onlyRelevantOutputs: query.where.onlyRelevantOutputs
  }));
}
function merge(array, el) {
  if (isEmpty(array) && isUndefined(el)) return;
  const set = new Set(array ?? []);
  if (!isUndefined(el)) set.add(el);
  return Array.from(set.values());
}
function hasMempool(data) {
  return !!data?.mempool?.boxes;
}
function hasConfirmed(data) {
  return !!data?.boxes;
}
function mapConfirmedBox(box, mapper) {
  const mapped = mapBox(box, mapper);
  mapped.confirmed = true;
  return mapped;
}
function mapUnconfirmedBox(box, mapper) {
  const mapped = mapBox(box, mapper);
  mapped.confirmed = false;
  return mapped;
}
function mapBox(box, mapper) {
  return {
    boxId: box.boxId,
    transactionId: box.transactionId,
    value: mapper(box.value),
    ergoTree: box.ergoTree,
    assets: box.assets.map((t) => ({ tokenId: t.tokenId, amount: mapper(t.amount) })),
    creationHeight: box.creationHeight,
    additionalRegisters: box.additionalRegisters,
    index: box.index
  };
}
function mapUnconfirmedTransaction(tx, mapper) {
  return {
    transactionId: tx.transactionId,
    timestamp: Number(tx.timestamp),
    inputs: tx.inputs.map((i) => ({
      spendingProof: {
        // biome-ignore lint/style/noNonNullAssertion: bad type declarations at '@ergo-graphql/type'
        extension: i.extension,
        // biome-ignore lint/style/noNonNullAssertion: bad type declarations at '@ergo-graphql/type'
        proofBytes: i.proofBytes
      },
      // biome-ignore lint/style/noNonNullAssertion: bad type declarations at '@ergo-graphql/type'
      ...mapBox(i.box, mapper)
    })),
    dataInputs: tx.dataInputs.map((di) => ({ boxId: di.boxId })),
    outputs: tx.outputs.map((b) => mapBox(b, mapper)),
    confirmed: false
  };
}
function mapConfirmedTransaction(tx, mapper) {
  return {
    transactionId: tx.transactionId,
    timestamp: Number(tx.timestamp),
    inputs: tx.inputs.map((i) => ({
      spendingProof: {
        // biome-ignore lint/style/noNonNullAssertion: bad type declarations at '@ergo-graphql/type'
        extension: i.extension,
        // biome-ignore lint/style/noNonNullAssertion: bad type declarations at '@ergo-graphql/type'
        proofBytes: i.proofBytes
      },
      // biome-ignore lint/style/noNonNullAssertion: bad type declarations at '@ergo-graphql/type'
      ...mapBox(i.box, mapper)
    })),
    dataInputs: tx.dataInputs.map((di) => ({ boxId: di.boxId })),
    outputs: tx.outputs.map((b) => mapBox(b, mapper)),
    height: tx.inclusionHeight,
    headerId: tx.headerId,
    index: tx.index,
    confirmed: true
  };
}
function isRequestParam(obj) {
  return typeof obj === "object" && obj.url !== void 0;
}
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/

export { ErgoGraphQLProvider, createGqlOperation, exponentialRetry, getOpName, gql, isRequestParam, request };
//# sourceMappingURL=index.mjs.map
//# sourceMappingURL=index.mjs.map